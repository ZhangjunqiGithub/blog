<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端常见理论知识 | 编程分享讨论栈</title><meta name="author" content="JQ Zhang"><meta name="copyright" content="JQ Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？1234567891001.浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根 域名服务器)02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手）03.服务器 301 重定向（从 example.com 重定向到 ww">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见理论知识">
<meta property="og:url" content="https://zhangjunqigithub.github.io/blog/2023/07/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="编程分享讨论栈">
<meta property="og:description" content="1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？1234567891001.浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根 域名服务器)02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手）03.服务器 301 重定向（从 example.com 重定向到 ww">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.206fbddcfd785cb6351a60661235ee63?rik=PybKqjZUdBgvfw&riu=http%3a%2f%2flogoju.cn%2fwp-content%2fuploads%2f2016%2f08%2flogoju.cn_2016-08-27_05-22-44.jpg&ehk=DdmlhEY629M2WnHe69pOEVvxGFmMeRUaroJ6zsZ44JU%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-06-30T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-06T03:09:52.300Z">
<meta property="article:author" content="JQ Zhang">
<meta property="article:tag" content="前端常见理论知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.206fbddcfd785cb6351a60661235ee63?rik=PybKqjZUdBgvfw&riu=http%3a%2f%2flogoju.cn%2fwp-content%2fuploads%2f2016%2f08%2flogoju.cn_2016-08-27_05-22-44.jpg&ehk=DdmlhEY629M2WnHe69pOEVvxGFmMeRUaroJ6zsZ44JU%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="https://raw.githubusercontent.com/ZhangjunqiGithub/picture/master/blogAvator.jpg"><link rel="canonical" href="https://zhangjunqigithub.github.io/blog/2023/07/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/blog/',
  algolia: {"appId":"DOUQTLBQKA","apiKey":"a9673e873d0aa7a0ce75624b7fb70120","indexName":"my_hexo_blog","hits":{"per_page":6},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端常见理论知识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-06 11:09:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/ZhangjunqiGithub/picture/master/blogAvator.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/blog/tags/"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/blog/categories/"><div class="headline">Categories</div><div class="length-num">25</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.206fbddcfd785cb6351a60661235ee63?rik=PybKqjZUdBgvfw&amp;riu=http%3a%2f%2flogoju.cn%2fwp-content%2fuploads%2f2016%2f08%2flogoju.cn_2016-08-27_05-22-44.jpg&amp;ehk=DdmlhEY629M2WnHe69pOEVvxGFmMeRUaroJ6zsZ44JU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><nav id="nav"><span id="blog-info"><a href="/blog/" title="编程分享讨论栈"><span class="site-name">编程分享讨论栈</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端常见理论知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-30T16:00:00.000Z" title="Created 2023-07-01 00:00:00">2023-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-08-06T03:09:52.300Z" title="Updated 2024-08-06 11:09:52">2024-08-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">前端常见理论知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端常见理论知识"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？"><a href="#1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？" class="headerlink" title="1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？"></a>1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">01.浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根 域名服务器)</span><br><span class="line">02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手）</span><br><span class="line">03.服务器 301 重定向（从 example.com 重定向到 www.example.com）</span><br><span class="line">04.浏览器跟踪重定向地址，请求另一个带 www 的网址</span><br><span class="line">05.服务器处理请求（通过路由读取资源）</span><br><span class="line">06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 &#x27;text/html&#x27;）</span><br><span class="line">07.浏览器进 DOM 树构建</span><br><span class="line">08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS 等）</span><br><span class="line">09.浏览器显示完成页面</span><br><span class="line">10.浏览器发送异步请求</span><br></pre></td></tr></table></figure>

<h3 id="2、进程与线程的联系和互相通信"><a href="#2、进程与线程的联系和互相通信" class="headerlink" title="2、进程与线程的联系和互相通信"></a>2、进程与线程的联系和互相通信</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">进程和线程是操作系统中管理和执行程序的基本单位。它们之间有着密切的联系，并且可以通过各种机制进行通信。</span><br><span class="line"></span><br><span class="line">联系：</span><br><span class="line">共享资源： 进程内的所有线程共享同一份内存空间和其他资源，包括文件描述符、打开的文件、信号处理器等。这意味着进程中的线程可以相互访问和修改彼此的数据。</span><br><span class="line"></span><br><span class="line">隔离性： 每个进程有自己的地址空间，进程之间的地址空间是相互独立的。而线程是在进程内部创建的，它们共享进程的地址空间。</span><br><span class="line"></span><br><span class="line">资源分配： 进程是操作系统中的资源分配单位，每个进程拥有自己的内存空间、文件描述符、I/O 等。而线程是 CPU 调度的基本单位，是进程内的执行单元。</span><br><span class="line"></span><br><span class="line">通信：</span><br><span class="line">共享内存： 进程内的所有线程共享同一份内存空间，因此它们可以通过共享内存来进行通信。通过在内存中创建共享变量或者使用同步机制（例如互斥锁、信号量）来控制对共享内存的访问，线程可以进行相互通信。</span><br><span class="line"></span><br><span class="line">消息传递： 线程可以通过消息队列、管道、套接字等方式进行消息传递。进程间通信（IPC，Inter-Process Communication）的机制同样适用于进程内的线程间通信。这些机制包括管道、消息队列、信号量、共享内存等。</span><br><span class="line"></span><br><span class="line">同步机制： 线程可以使用各种同步机制来确保多个线程之间的顺序执行或者避免竞态条件。常见的同步机制包括互斥锁、条件变量、信号量等。</span><br></pre></td></tr></table></figure>

<h3 id="3、https为什么比http更安全"><a href="#3、https为什么比http更安全" class="headerlink" title="3、https为什么比http更安全"></a>3、https为什么比http更安全</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTPS（HyperText Transfer Protocol Secure）相对于HTTP（HyperText Transfer Protocol）更安全，主要体现在以下几个方面：</span><br><span class="line"></span><br><span class="line">加密通信： HTTPS 使用 SSL/TLS 协议对数据进行加密传输，而 HTTP 不进行加密，数据以明文形式传输。通过使用加密技术，HTTPS 可以防止窃听者（例如黑客或网络监听器）截取和查看通信中的敏感信息，如用户登录凭证、银行卡信息等。</span><br><span class="line"></span><br><span class="line">身份验证： HTTPS 要求服务器提供数字证书，证明其身份的合法性。这些数字证书由受信任的证书颁发机构（Certificate Authorities，CA）签发，用于验证服务器的身份。这样可以防止中间人攻击，确保客户端与服务器之间的通信不被篡改或伪装。</span><br><span class="line"></span><br><span class="line">完整性保护： HTTPS 使用数字签名技术来保证数据的完整性，防止数据在传输过程中被篡改或修改。通过对传输的数据进行数字签名，可以确保数据在传输过程中没有被篡改，从而保证数据的完整性。</span><br><span class="line"></span><br><span class="line">浏览器安全机制： 现代的 Web 浏览器对使用 HTTPS 访问的网站提供更高的安全性支持。例如，浏览器通常会在地址栏中显示一个锁图标来指示连接是安全的，并警告用户正在访问的网站是否存在安全风险。</span><br><span class="line"></span><br><span class="line">总的来说，HTTPS 相对于 HTTP 更安全，因为它使用加密技术对数据进行保护，提供了身份验证和完整性保护机制，以及浏览器安全支持。这些安全特性使得 HTTPS 成为更可靠的通信协议，适用于传输敏感信息的场景，例如登录、支付等。</span><br></pre></td></tr></table></figure>

<h3 id="4、html和css的解析顺序，css的解析不会阻塞html的解析，会阻塞Html的渲染的原因"><a href="#4、html和css的解析顺序，css的解析不会阻塞html的解析，会阻塞Html的渲染的原因" class="headerlink" title="4、html和css的解析顺序，css的解析不会阻塞html的解析，会阻塞Html的渲染的原因"></a>4、html和css的解析顺序，css的解析不会阻塞html的解析，会阻塞Html的渲染的原因</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html和css可以并行同时解析，但是因为需要等到了css和html都解析完然后合并成为一个DOM树然后再去渲染</span><br></pre></td></tr></table></figure>

<h3 id="5、DOMContentLoad和load的区别"><a href="#5、DOMContentLoad和load的区别" class="headerlink" title="5、DOMContentLoad和load的区别"></a>5、DOMContentLoad和load的区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOM树加载完成后并不代表页面就加载完成了，因为还有一些静态的资源需要去请求，而DOMContentLoad就是DOM树加载完成了，但是那些静态资源还没有进行请求的情况，而Load是全部资源都请求完毕</span><br></pre></td></tr></table></figure>

<h3 id="6、重绘和回流是什么以及如何避免重绘和回流关于重绘和回流相关的方requestAnimationFrame和getBoundingClientRect和intersectionObserver"><a href="#6、重绘和回流是什么以及如何避免重绘和回流关于重绘和回流相关的方requestAnimationFrame和getBoundingClientRect和intersectionObserver" class="headerlink" title="6、重绘和回流是什么以及如何避免重绘和回流关于重绘和回流相关的方requestAnimationFrame和getBoundingClientRect和intersectionObserver"></a>6、重绘和回流是什么以及如何避免重绘和回流关于重绘和回流相关的方requestAnimationFrame和getBoundingClientRect和intersectionObserver</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">重绘（Repaint）和回流（Reflow）是浏览器渲染页面时涉及的两个重要概念。</span><br><span class="line"></span><br><span class="line">重绘（Repaint）： 当元素的样式（如颜色、背景等）发生改变，但不影响其几何形状和位置时，浏览器会触发重绘。在重绘过程中，浏览器重新绘制受影响的部分，但不会影响其他元素的布局。</span><br><span class="line"></span><br><span class="line">回流（Reflow）： 当元素的几何属性发生改变，例如宽度、高度、位置等，或者当添加、删除、隐藏元素时，浏览器会触发回流。在回流过程中，浏览器需要重新计算并更新受影响元素及其子元素的几何属性，并重新布局页面。</span><br><span class="line"></span><br><span class="line">由于重绘和回流都会导致浏览器重新渲染页面的部分或全部内容，因此它们都可能引起页面性能问题，尤其是在大型、复杂的页面中。</span><br><span class="line"></span><br><span class="line">为了避免重绘和回流，可以采取以下几个策略：</span><br><span class="line"></span><br><span class="line">使用 CSS 动画代替 JavaScript 动画： 使用 CSS 进行动画效果可以利用硬件加速，减少重绘和回流的发生，从而提高性能。</span><br><span class="line"></span><br><span class="line">批量修改样式： 当需要修改多个元素的样式时，尽可能一次性进行修改，而不是分开多次修改。这样可以减少重绘和回流的次数。</span><br><span class="line"></span><br><span class="line">使用离线 DOM 操作： 在需要对多个 DOM 元素进行操作时，可以先将它们从文档中移除，进行操作后再添加回文档中，这样可以避免多次回流。</span><br><span class="line"></span><br><span class="line">避免强制同步布局： 尽量避免直接获取布局信息（如 offsetTop、offsetLeft 等），因为这会导致浏览器强制进行同步布局。如果需要获取元素的几何属性，可以使用异步的方式，例如使用 requestAnimationFrame 或 getBoundingClientRect 等方法。</span><br><span class="line"></span><br><span class="line">使用 CSS3 属性优化： 部分 CSS3 属性（如 transform、opacity 等）可以在不引起回流的情况下改变元素的外观，因此在可能的情况下尽量使用这些属性。</span><br><span class="line"></span><br><span class="line">通过以上方法，可以有效减少重绘和回流的次数，提高页面性能和用户体验。</span><br><span class="line">requestAnimationFrame（RAF）： 这是一个用于执行动画效果的浏览器 API。与传统的 setTimeout 或 setInterval 相比，requestAnimationFrame 更加高效，因为它会在浏览器下次重绘之前调用指定的回调函数。这样可以确保动画在每一帧之间的间隔是平滑的，避免了丢帧和视觉上的不连续性。使用 requestAnimationFrame 可以帮助我们优化动画效果，提高页面性能。</span><br><span class="line"></span><br><span class="line">getBoundingClientRect： 这是一个 DOM API，用于获取指定元素相对于视口的位置和尺寸信息。使用 getBoundingClientRect 可以方便地获取元素的位置信息，从而进行一些基于元素位置的操作，例如实现元素的滚动、懒加载、动画等。这个方法可以避免使用 offsetTop、offsetLeft 等属性来计算元素的位置，从而提高性能。</span><br><span class="line"></span><br><span class="line">Intersection Observer（交叉观察器）： 这是一个用于监听元素与其祖先元素或视口的交叉状态的 API。通过使用 Intersection Observer，可以异步地观察元素的可见性，并在元素进入或离开视口时触发回调函数。这个 API 可以帮助我们实现诸如懒加载、无限滚动、元素的渐显动画等效果，而且能够避免因频繁监听元素可见性而导致的性能问题。</span><br></pre></td></tr></table></figure>

<h3 id="7、从后端请求到一个数组后如何渲染出来性能会更好"><a href="#7、从后端请求到一个数组后如何渲染出来性能会更好" class="headerlink" title="7、从后端请求到一个数组后如何渲染出来性能会更好"></a>7、从后端请求到一个数组后如何渲染出来性能会更好</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">分页加载： 将大量数据分成多个页面或分块加载，而不是一次性加载所有数据。前端可以根据用户的浏览情况，动态加载所需的数据分页，以减少页面加载时间和减轻服务器负载。</span><br><span class="line"></span><br><span class="line">虚拟滚动： 使用虚拟滚动技术，只渲染用户当前可见区域内的数据。这样可以降低内存占用和渲染成本，并提高页面加载速度和性能。常见的虚拟滚动库包括 React Virtualized、vue-virtual-scroller 等。</span><br><span class="line"></span><br><span class="line">增量渲染： 将数据分批次加载并逐步渲染到页面上，而不是一次性加载所有数据。这种方法可以减少页面阻塞时间和首屏加载时间，提高用户体验。你可以根据用户的滚动行为来触发数据的增量加载。</span><br><span class="line"></span><br><span class="line">客户端缓存： 在前端使用客户端缓存技术，如浏览器缓存、LocalStorage 或 IndexedDB，缓存已经加载过的数据，减少重复请求和渲染。这样可以减少服务器负载，并提高页面加载速度。</span><br><span class="line"></span><br><span class="line">数据压缩： 如果数据量很大，可以考虑对数据进行压缩，减小数据传输的大小，从而降低网络传输成本和加载时间。可以使用 gzip、Brotli 等压缩算法来压缩数据。</span><br><span class="line"></span><br><span class="line">异步加载： 使用异步加载技术，如异步请求、Web Workers 等，将数据加载和渲染过程与主线程分离，避免阻塞页面渲染。这样可以提高页面的响应速度和性能。</span><br><span class="line"></span><br><span class="line">综上所述，通过以上方法的组合使用，可以显著提高从后端请求到大量数据后的渲染性能，并实现更好的用户体验。</span><br></pre></td></tr></table></figure>

<h3 id="8、DocumentFragment文档碎片列表优化"><a href="#8、DocumentFragment文档碎片列表优化" class="headerlink" title="8、DocumentFragment文档碎片列表优化"></a>8、DocumentFragment文档碎片列表优化</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DocumentFragment 实现了文档碎片列表优化的主要原理是减少 DOM 操作的次数，从而提高页面渲染性能。具体来说，使用 DocumentFragment 可以将多个 DOM 操作合并成一次操作，减少了页面重绘和回流的次数，优化了页面的渲染性能。以下是 DocumentFragment 实现文档碎片列表优化的几个方面：</span><br><span class="line"></span><br><span class="line">批量操作节点： 将多个节点添加到 DocumentFragment 中，然后一次性将 DocumentFragment 添加到文档中。由于添加到 DocumentFragment 的节点在内存中，并没有真正添加到文档中，因此这些操作不会触发页面的重绘和回流。当将 DocumentFragment 添加到文档中时，浏览器只需要一次性更新页面，从而减少了页面渲染的时间。</span><br><span class="line"></span><br><span class="line">减少 DOM 操作： 使用 DocumentFragment 可以将多个 DOM 操作合并成一次操作，从而减少了页面的 DOM 操作次数。这样可以降低页面的渲染成本，提高页面的渲染效率。</span><br><span class="line"></span><br><span class="line">减少重绘和回流： 页面的重绘和回流是由于 DOM 结构发生变化而导致的，使用 DocumentFragment 可以减少页面的重绘和回流次数。因为将多个 DOM 操作合并成一次操作，可以减少页面的 DOM 结构变化，从而减少了页面的重绘和回流。</span><br><span class="line"></span><br><span class="line">优化动态列表： 在动态列表中，使用 DocumentFragment 可以优化性能。当需要频繁添加、删除或更新列表项时，可以将新的列表项添加到 DocumentFragment 中，然后一次性将 DocumentFragment 添加到列表中。这样可以减少页面的 DOM 操作次数，提高页面的渲染效率。</span><br><span class="line"></span><br><span class="line">综上所述，DocumentFragment 实现了文档碎片列表优化的主要原理是减少 DOM 操作次数，降低页面的重绘和回流次数，从而提高了页面的渲染性能。通过合理地使用 DocumentFragment，可以优化页面的渲染过程，提高用户体验。</span><br><span class="line">1、创建文档碎片： 首先，使用 document.createDocumentFragment() 方法创建一个新的文档碎片对象</span><br><span class="line">2、将结点添加到文档碎片中：fragment.appendChild(div);</span><br><span class="line">3、将文档碎片插入到文档中：document.body.appendChild(fragment);</span><br><span class="line"> 当文档碎片中的节点准备好后，可以将整个文档碎片一次性地插入到文档中，而不是逐个插入节点。这样可以减少 DOM 操作的次数，提高性能。</span><br></pre></td></tr></table></figure>

<h3 id="9、Mutationobserver用于监控DOM的变化：使用场景例如：自己在做水印的时候，我们要防止别人把水印给删掉，那么我们就需要这个方法去监控到这个DOM被删除了，此时我们可以再去执行一下生成水印的方法。第二个就是这个方法还可以计算守屏时间"><a href="#9、Mutationobserver用于监控DOM的变化：使用场景例如：自己在做水印的时候，我们要防止别人把水印给删掉，那么我们就需要这个方法去监控到这个DOM被删除了，此时我们可以再去执行一下生成水印的方法。第二个就是这个方法还可以计算守屏时间" class="headerlink" title="9、Mutationobserver用于监控DOM的变化：使用场景例如：自己在做水印的时候，我们要防止别人把水印给删掉，那么我们就需要这个方法去监控到这个DOM被删除了，此时我们可以再去执行一下生成水印的方法。第二个就是这个方法还可以计算守屏时间"></a>9、Mutationobserver用于监控DOM的变化：使用场景例如：自己在做水印的时候，我们要防止别人把水印给删掉，那么我们就需要这个方法去监控到这个DOM被删除了，此时我们可以再去执行一下生成水印的方法。第二个就是这个方法还可以计算守屏时间</h3><h3 id="10、computed和watch的使用场景和区别：计算属性：多对一（缓存）监听属性：一对多。响应式的原理-双向绑定的原理"><a href="#10、computed和watch的使用场景和区别：计算属性：多对一（缓存）监听属性：一对多。响应式的原理-双向绑定的原理" class="headerlink" title="10、computed和watch的使用场景和区别：计算属性：多对一（缓存）监听属性：一对多。响应式的原理(双向绑定的原理)"></a>10、computed和watch的使用场景和区别：计算属性：多对一（缓存）监听属性：一对多。响应式的原理(双向绑定的原理)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Computed 属性</span><br><span class="line">computed 属性用于声明一个计算属性，它的值是根据其他响应式数据计算而来的，只有当依赖的数据发生变化时，才会重新计算。</span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line">派生数据： 当需要根据其他响应式数据计算出一些派生数据时，通常可以使用 computed。例如，计算商品总价、过滤数据、格式化日期等。</span><br><span class="line"></span><br><span class="line">缓存数据： computed 属性会缓存计算结果，在依赖数据不变的情况下，多次访问计算属性会返回缓存的结果，避免重复计算。</span><br><span class="line"></span><br><span class="line">简化模板逻辑： 将一些复杂的逻辑抽象为计算属性，可以使模板更加简洁清晰，减少模板中的计算逻辑。</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">特性： computed 属性是基于依赖数据的计算属性，它的值是响应式的，会根据依赖数据的变化自动更新。</span><br><span class="line"></span><br><span class="line">语法： 在 Vue.js 组件中使用 computed 属性时，可以像访问普通属性一样直接使用，而不需要在模板中添加函数调用。</span><br><span class="line"></span><br><span class="line">Watcher 监听器</span><br><span class="line">watch 监听器用于观察数据的变化并执行一些副作用，例如执行异步操作、发起网络请求、手动操作 DOM 等。</span><br><span class="line"></span><br><span class="line">使用场景：</span><br><span class="line">监听数据变化： 当需要监听某个数据的变化并进行一些操作时，通常可以使用 watch。例如，监听输入框的变化、监听路由参数的变化等。</span><br><span class="line"></span><br><span class="line">异步操作： 在监听到数据变化后，需要执行一些异步操作时，可以使用 watch。例如，监听搜索关键词的变化，并发起搜索请求。</span><br><span class="line"></span><br><span class="line">深度监听： watch 可以深度监听对象或数组的变化，可以在对象或数组发生深层次变化时执行回调函数。</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">特性： watch 监听器是用于观察数据的变化并执行副作用，它是一个函数，接收两个参数：新值和旧值。</span><br><span class="line"></span><br><span class="line">语法： 在 Vue.js 组件中使用 watch 监听器时，需要在组件选项中使用 watch 属性，并指定需要监听的数据以及对应的回调函数。</span><br><span class="line"></span><br><span class="line">总的来说，computed 适用于计算派生数据和简化模板逻辑，而 watch 适用于监听数据变化并执行副作用，例如异步操作和深度监听。在实际开发中，根据具体的需求选择合适的响应式方式来处理数据变化是非常重要的。</span><br><span class="line"></span><br><span class="line">数据劫持（Data Observation）： Vue.js 使用数据劫持技术来实现响应式数据。在组件初始化时，Vue.js 会递归遍历组件的所有属性，并使用 Object.defineProperty() 方法将每个属性转换为 getter 和 setter。这样当访问或修改属性时，Vue.js 将会捕获到这些操作，并触发相应的更新。</span><br><span class="line"></span><br><span class="line">依赖追踪（Dependency Tracking）： 当模板中使用了数据时，Vue.js 会建立数据与视图之间的依赖关系。每个响应式数据都会有一个依赖收集器，用于收集依赖该数据的所有 Watcher 对象（观察者）。当数据被访问时，Watcher 对象会将自己添加到数据的依赖收集器中。</span><br><span class="line"></span><br><span class="line">发布订阅模式（Pub/Sub Pattern）： 当响应式数据发生变化时，会通知所有依赖该数据的 Watcher 对象进行更新。这种通知机制是通过发布订阅模式实现的，即数据作为发布者，Watcher 对象作为订阅者，当数据发生变化时，发布者会向所有订阅者发送通知。</span><br><span class="line"></span><br><span class="line">虚拟 DOM（Virtual DOM）： Vue.js 使用虚拟 DOM 来提高渲染性能。当数据发生变化时，Vue.js 不会立即更新 DOM，而是将变化记录在虚拟 DOM 中，并进行比对。通过比对虚拟 DOM 的变化，Vue.js 可以找出最小的更新范围，并将更新应用到实际的 DOM 上，从而减少渲染次数和提高性能。</span><br><span class="line"></span><br><span class="line">双向绑定（Two-way Data Binding）： 双向绑定是 Vue.js 的另一个核心特性，它允许数据的变化能够自动反映到视图上，同时也允许视图上的变化能够自动同步到数据中。在双向绑定中，当数据发生变化时，会触发更新视图的操作；当视图发生变化时，会触发更新数据的操作。</span><br></pre></td></tr></table></figure>

<h3 id="11、dep和watcher互相收集"><a href="#11、dep和watcher互相收集" class="headerlink" title="11、dep和watcher互相收集"></a>11、dep和watcher互相收集</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 Vue.js 的响应式系统中，Dep（依赖收集器）和 Watcher（观察者）之间确实会相互收集。下面解释一下它们之间的关系：</span><br><span class="line"></span><br><span class="line">Dep（依赖收集器）： Dep 是一个依赖收集器，用于收集依赖于响应式数据的 Watcher 对象。每个响应式数据都会有一个对应的 Dep 对象，它是一个容器，用于存储依赖于该数据的 Watcher 对象。</span><br><span class="line"></span><br><span class="line">Watcher（观察者）： Watcher 是一个观察者对象，用于观察响应式数据的变化并执行相应的回调函数。每个 Watcher 对象都会关联一个或多个响应式数据，并在数据发生变化时收到通知并执行更新操作。</span><br><span class="line"></span><br><span class="line">依赖收集过程： 在 Vue.js 的数据劫持过程中，当模板中使用了响应式数据时，会创建一个 Watcher 对象，并将该 Watcher 对象添加到对应数据的依赖收集器（Dep 对象）中。这样一来，当数据发生变化时，依赖于该数据的所有 Watcher 对象都会收到通知并执行更新操作。</span><br><span class="line"></span><br><span class="line">Watchers 收集过程： 在模板编译过程中，当解析到模板中的表达式或指令时，会创建一个 Watcher 对象，并将其关联到对应的响应式数据。这样一来，当数据发生变化时，与之相关的 Watcher 对象就能够收到通知并执行更新操作。</span><br><span class="line"></span><br><span class="line">通过这种方式，Dep 对象和 Watcher 对象之间建立了一个联系，实现了数据与视图之间的响应式绑定。当数据发生变化时，Dep 对象会通知所有依赖于该数据的 Watcher 对象进行更新，从而实现了数据的响应式更新和双向绑定。</span><br></pre></td></tr></table></figure>

<h3 id="12、diff算法"><a href="#12、diff算法" class="headerlink" title="12、diff算法"></a>12、diff算法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.js 和 React 等现代 JavaScript 框架都使用了 Virtual DOM 和 diff 算法来提高页面的性能。下面是 diff 算法的基本原理：</span><br><span class="line"></span><br><span class="line">虚拟 DOM（Virtual DOM）： 在 diff 算法中，首先会通过 JavaScript 对象模拟出一颗虚拟 DOM 树，即 Virtual DOM。这颗虚拟 DOM 树和真实 DOM 树结构一样，但是只是存在于内存中，并没有实际渲染到页面上。</span><br><span class="line"></span><br><span class="line">对比两棵树： 当数据发生变化时，会生成一棵新的虚拟 DOM 树。此时，会将新的虚拟 DOM 树和旧的虚拟 DOM 树进行对比，找出它们之间的差异。这个过程就是 diff 算法的核心。</span><br><span class="line"></span><br><span class="line">更新差异节点： 在对比过程中，会将两棵树的节点逐个对比，找出新增、删除、移动或更新的节点。然后根据这些差异，生成一系列 DOM 操作指令（如插入、删除、更新等），并将这些指令应用到实际的 DOM 树上，从而实现页面的更新。</span><br><span class="line"></span><br><span class="line">优化策略： 在执行 diff 算法时，会采用一些优化策略来提高性能。例如，diff 算法会尽量避免对整棵树进行完全对比，而是采用深度优先遍历的方式，尽早发现不同之处，并尽量减少不必要的 DOM 操作。</span><br><span class="line"></span><br><span class="line">总的来说，diff 算法通过对比两棵虚拟 DOM 树的差异，找出需要更新的节点，并生成一系列更新指令，从而实现页面的高效更新。通过使用 diff 算法，可以最小化页面更新的开销，提高页面的渲染性能。</span><br></pre></td></tr></table></figure>

<h3 id="13、flex布局（blog）"><a href="#13、flex布局（blog）" class="headerlink" title="13、flex布局（blog）"></a>13、flex布局（blog）</h3><h3 id="14、ES6：箭头函数为什么不能作为构造函数"><a href="#14、ES6：箭头函数为什么不能作为构造函数" class="headerlink" title="14、ES6：箭头函数为什么不能作为构造函数"></a>14、ES6：箭头函数为什么不能作为构造函数</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">箭头函数不能作为构造函数的主要原因是因为箭头函数没有自己的 this 绑定。在普通函数中，this 的值是在函数被调用时动态确定的，而在箭头函数中，this 的值是由它定义时所在的词法作用域决定的，无法被改变。</span><br><span class="line"></span><br><span class="line">在箭头函数中，this 的值是继承自外围作用域的，因此无法通过 new 关键字来创建一个新的对象并绑定到 this 上。如果尝试使用箭头函数作为构造函数来创建实例，会导致以下问题：</span><br><span class="line"></span><br><span class="line">箭头函数中的 this 无法被修改，即使使用了 new 关键字也无效。</span><br><span class="line">箭头函数没有自己的 prototype 属性，因此无法通过 new 关键字来创建原型链。</span><br><span class="line">因此，为了避免混淆和错误，ECMAScript 6 标准规定箭头函数不能作为构造函数来使用。如果需要使用构造函数来创建对象，应该使用普通的函数声明或函数表达式。</span><br></pre></td></tr></table></figure>

<h3 id="15、promise相关的内容，解决回调地狱问题"><a href="#15、promise相关的内容，解决回调地狱问题" class="headerlink" title="15、promise相关的内容，解决回调地狱问题"></a>15、promise相关的内容，解决回调地狱问题</h3><h3 id="16、需求：用promise封装了一个请求数据的函数，如果5s后还没请求到数据，就显示请求超时"><a href="#16、需求：用promise封装了一个请求数据的函数，如果5s后还没请求到数据，就显示请求超时" class="headerlink" title="16、需求：用promise封装了一个请求数据的函数，如果5s后还没请求到数据，就显示请求超时"></a>16、需求：用promise封装了一个请求数据的函数，如果5s后还没请求到数据，就显示请求超时</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你可以使用 Promise 的 Promise.race() 方法来实现这个功能。Promise.race() 方法接收一个 Promise 数组作为参数，并返回一个新的 Promise，该 Promise 将与第一个解决（或拒绝）的 Promise 相关联。</span><br><span class="line"></span><br><span class="line">下面是一个示例代码，演示了如何使用 Promise.race() 来实现请求超时的功能：</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟异步请求</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 模拟请求成功</span></span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&#x27;Data received&#x27;</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>); <span class="comment">// 这里设置请求超时时间为3秒</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchWithTimeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个 Promise，用于控制请求超时</span></span><br><span class="line">  <span class="keyword">const</span> timeoutPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 指定超时时间为5秒</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Request timed out&#x27;</span>));</span><br><span class="line">    &#125;, <span class="number">5000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 Promise.race() 方法，同时发起数据请求和超时控制的 Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">race</span>([<span class="title function_">fetchData</span>(), timeoutPromise]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数并处理结果</span></span><br><span class="line"><span class="title function_">fetchWithTimeout</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 如果请求成功，则输出数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error.<span class="property">message</span>); <span class="comment">// 如果请求超时或失败，则输出错误信息</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个示例中，<code>fetchData()</code> 函数模拟了一个异步请求，实际项目中可以替换为真实的请求函数。然后，<code>fetchWithTimeout()</code> 函数使用 <code>Promise.race()</code> 方法将请求数据的 Promise 和超时控制的 Promise 组合在一起，以实现超时功能。如果请求在 3 秒内完成，则会正常返回数据；如果请求在 5 秒内仍未完成，则会触发超时，返回一个错误。</p>
</blockquote>
<h3 id="17、promise的all方法：请求所有都成功才会返回成功，如果有一个失败就会返回那个失败"><a href="#17、promise的all方法：请求所有都成功才会返回成功，如果有一个失败就会返回那个失败" class="headerlink" title="17、promise的all方法：请求所有都成功才会返回成功，如果有一个失败就会返回那个失败"></a>17、promise的all方法：请求所有都成功才会返回成功，如果有一个失败就会返回那个失败</h3><h3 id="18、promise的allSettled方法"><a href="#18、promise的allSettled方法" class="headerlink" title="18、promise的allSettled方法"></a>18、promise的allSettled方法</h3><blockquote>
<p><code>Promise.allSettled()</code> 是 ES2020 引入的一个静态方法，它接收一个 Promise 数组作为参数，返回一个新的 Promise，该 Promise 在所有输入的 Promise 都已经完成（即 resolved 或 rejected）后才会被 resolve。</p>
</blockquote>
<blockquote>
<p>不同于 <code>Promise.all()</code> 方法，<code>Promise.allSettled()</code> 不会在输入的 Promise 中有任何一个被拒绝（rejected）时立即中断，并且它返回的 Promise 的状态总是成功（resolved）。返回的 Promise 的结果是一个包含所有输入 Promise 的结果的数组，每个元素是一个对象，包含了该 Promise 的状态和值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">42</span>),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Error occurred&#x27;</span>)),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;Delayed result&#x27;</span>), <span class="number">1000</span>))</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>(promises)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    results.<span class="title function_">forEach</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">status</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Fulfilled:&#x27;</span>, result.<span class="property">value</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Rejected:&#x27;</span>, result.<span class="property">reason</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个示例中，<code>promises</code> 数组包含了三个 Promise 对象，其中一个是成功的，一个是失败的，还有一个是 1 秒后返回结果的 Promise。<code>Promise.allSettled()</code> 方法会等待所有的 Promise 都已经 settled（即 resolved 或 rejected）后，返回一个包含所有 Promise 的结果的数组。在 <code>then</code> 方法中，我们可以根据每个结果对象的 <code>status</code> 属性来判断对应的 Promise 是成功还是失败，并输出相应的信息。</p>
</blockquote>
<h3 id="19、async-await解决了什么问题是如何解决的"><a href="#19、async-await解决了什么问题是如何解决的" class="headerlink" title="19、async&#x2F;await解决了什么问题是如何解决的"></a>19、async&#x2F;await解决了什么问题是如何解决的</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">解决回调地狱（Callback Hell）： 在传统的 JavaScript 异步编程中，经常会出现多层嵌套的回调函数，这种情况被称为“回调地狱”。回调地狱使得代码难以理解、难以维护，而且容易导致代码混乱、出错。async/await 通过使用 async 函数和 await 关键字，可以让异步代码以同步的方式书写，从而避免了回调地狱的问题，使代码更加清晰易读。</span><br><span class="line"></span><br><span class="line">优化 Promise 的链式调用： 在使用 Promise 进行异步编程时，经常会使用链式调用的方式来处理多个异步操作。虽然 Promise 提供了优雅的解决方案，但是在处理多个异步操作时，仍然需要嵌套多层 then() 方法，导致代码复杂度增加。async/await 可以让异步操作像同步操作一样被执行，从而简化了 Promise 的链式调用。</span><br><span class="line"></span><br><span class="line">使用 async/await 的基本原理是：</span><br><span class="line"></span><br><span class="line">async 函数用来定义一个异步函数，它会返回一个 Promise 对象。在 async 函数内部，可以使用 await 关键字来等待其他 Promise 对象的结果，而不需要使用 then() 方法。</span><br><span class="line">await 关键字可以暂停异步函数的执行，等待 Promise 对象的状态变为 resolved 后，将 Promise 的 resolved 值作为 await 表达式的返回值，并继续执行 async 函数。</span><br><span class="line">通过使用 async/await，可以让异步代码的书写方式更加简洁、清晰，提高了代码的可读性和可维护性，同时也解决了回调地狱和 Promise 链式调用的问题。</span><br></pre></td></tr></table></figure>

<h3 id="20、图片和路由懒加载、防抖、节流、瀑布流（blog）"><a href="#20、图片和路由懒加载、防抖、节流、瀑布流（blog）" class="headerlink" title="20、图片和路由懒加载、防抖、节流、瀑布流（blog）"></a>20、图片和路由懒加载、防抖、节流、瀑布流（blog）</h3><h3 id="21、取消重复请求的问题，响应拦截器和请求拦截器"><a href="#21、取消重复请求的问题，响应拦截器和请求拦截器" class="headerlink" title="21、取消重复请求的问题，响应拦截器和请求拦截器"></a>21、取消重复请求的问题，响应拦截器和请求拦截器</h3><blockquote>
<p>取消重复请求是指在发起一个网络请求之前，先检查当前是否已经有相同的请求在进行中，如果是，则取消之前的请求，只保留最新的请求。这样可以避免因为重复请求而导致的资源浪费和性能问题。</p>
</blockquote>
<blockquote>
<p>在前端开发中，可以通过拦截器（interceptors）来实现取消重复请求的功能。通常，拦截器分为请求拦截器和响应拦截器。</p>
</blockquote>
<ul>
<li><blockquote>
<p><strong>请求拦截器（Request Interceptors）：</strong> 请求拦截器用于在发送请求之前对请求进行处理，例如添加公共参数、设置请求头等。在实现取消重复请求的功能时，可以在请求拦截器中判断当前是否存在相同的请求正在进行，如果存在，则取消之前的请求。这样可以确保每次只有一个请求被发送到服务器。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>响应拦截器（Response Interceptors）：</strong> 响应拦截器用于在接收到响应之后对响应进行处理，例如处理响应数据、错误处理等。在实现取消重复请求的功能时，可以在响应拦截器中处理请求的结果，例如保存请求的结果或者清除请求状态。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以下是一个简单的示例代码，演示了如何使用 Axios（一个流行的 HTTP 客户端库）和拦截器来实现取消重复请求的功能：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个变量用于保存当前正在进行的请求</span></span><br><span class="line"><span class="keyword">let</span> pendingRequest = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果存在正在进行的请求，则取消之前的请求</span></span><br><span class="line">    <span class="keyword">if</span> (pendingRequest) &#123;</span><br><span class="line">      pendingRequest.<span class="title function_">cancel</span>(<span class="string">&#x27;Request canceled due to new request&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个新的取消令牌</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">CancelToken</span> = axios.<span class="property">CancelToken</span>;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="title class_">CancelToken</span>.<span class="title function_">source</span>();</span><br><span class="line">    config.<span class="property">cancelToken</span> = source.<span class="property">token</span>;</span><br><span class="line">    pendingRequest = source;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理响应数据</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理请求失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发起请求</span></span><br><span class="line">instance.<span class="title function_">get</span>(<span class="string">&#x27;/api/data&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Response:&#x27;</span>, response.<span class="property">data</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error.<span class="property">message</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个示例中，我们创建了一个 Axios 实例，并使用请求拦截器和响应拦截器来实现取消重复请求的功能。在请求拦截器中，我们判断当前是否存在正在进行的请求，如果存在，则取消之前的请求，并创建一个新的取消令牌。这样可以确保每次只有一个请求被发送到服务器。</p>
</blockquote>
<h3 id="22、cookie和本地浏览器缓存有什么区别"><a href="#22、cookie和本地浏览器缓存有什么区别" class="headerlink" title="22、cookie和本地浏览器缓存有什么区别"></a>22、cookie和本地浏览器缓存有什么区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cookie 和本地浏览器缓存（LocalStorage 和 SessionStorage）都是用于在客户端存储数据的机制，但它们之间有一些区别，主要包括以下几点：</span><br><span class="line"></span><br><span class="line">存储位置：</span><br><span class="line"></span><br><span class="line">Cookie： Cookie 是存储在客户端的一种数据，它是由服务器发送给浏览器的一小段文本信息，每次请求时都会自动携带到服务器。Cookie 的大小一般受到限制（通常为 4KB 左右）。</span><br><span class="line">本地浏览器缓存： 本地浏览器缓存包括 LocalStorage 和 SessionStorage，它们都是存储在浏览器中的一种持久化的存储方式，可以用来保存较大量的数据（一般为几 MB）。</span><br><span class="line">生命周期：</span><br><span class="line"></span><br><span class="line">Cookie： Cookie 可以设置过期时间，可以是会话级的（浏览器关闭时失效）、永久的（过期时间为未来某个时间点）或者一段时间后过期。如果不设置过期时间，那么 Cookie 将默认为会话级，即在浏览器关闭时失效。</span><br><span class="line">本地浏览器缓存： LocalStorage 中的数据是永久保存的，除非用户手动删除，否则数据将一直保留在浏览器中；而 SessionStorage 中的数据只在当前会话（浏览器窗口）有效，关闭窗口后数据将被清除。</span><br><span class="line">与服务器通信：</span><br><span class="line"></span><br><span class="line">Cookie： 每次向服务器发起请求时，会将相应的 Cookie 自动发送给服务器，因此 Cookie 可以用来在客户端和服务器之间传递数据。</span><br><span class="line">本地浏览器缓存： 本地浏览器缓存的数据仅在客户端存储，不会自动发送给服务器，它们主要用于在客户端保存用户数据或应用状态。</span><br><span class="line">安全性：</span><br><span class="line"></span><br><span class="line">Cookie： 由于 Cookie 是存储在客户端的，因此可能受到跨站脚本（XSS）和跨站请求伪造（CSRF）等安全攻击的影响。为了增强安全性，可以将 Cookie 设置为 HttpOnly，使得 Cookie 无法被 JavaScript 访问。</span><br><span class="line">本地浏览器缓存： 本地浏览器缓存的数据只能通过 JavaScript 访问，不会被发送给服务器，因此相对于 Cookie 更安全。</span><br><span class="line">总的来说，Cookie 用于在客户端和服务器之间传递数据，并且具有较小的存储容量和可设置的生命周期，而本地浏览器缓存用于在客户端保存用户数据或应用状态，并且具有较大的存储容量和持久性。在实际开发中，根据具体的需求和安全考虑，选择合适的存储机制非常重要。</span><br></pre></td></tr></table></figure>

<h3 id="23、Vue3在Vue2上的优化，以及是如何优化的-blog"><a href="#23、Vue3在Vue2上的优化，以及是如何优化的-blog" class="headerlink" title="23、Vue3在Vue2上的优化，以及是如何优化的(blog)"></a>23、Vue3在Vue2上的优化，以及是如何优化的(blog)</h3><h3 id="24、JS闭包（blog）"><a href="#24、JS闭包（blog）" class="headerlink" title="24、JS闭包（blog）"></a>24、JS闭包（blog）</h3><h3 id="25、git的基本使用方法-blog"><a href="#25、git的基本使用方法-blog" class="headerlink" title="25、git的基本使用方法(blog)"></a>25、git的基本使用方法(blog)</h3><h3 id="26、JS全局作用域的特殊情况和var，let，const三者的特点和区别（blog）"><a href="#26、JS全局作用域的特殊情况和var，let，const三者的特点和区别（blog）" class="headerlink" title="26、JS全局作用域的特殊情况和var，let，const三者的特点和区别（blog）"></a>26、JS全局作用域的特殊情况和var，let，const三者的特点和区别（blog）</h3><h3 id="27、JS预解析-blog"><a href="#27、JS预解析-blog" class="headerlink" title="27、JS预解析(blog)"></a>27、JS预解析(blog)</h3><h3 id="28、数组去重（blog）"><a href="#28、数组去重（blog）" class="headerlink" title="28、数组去重（blog）"></a>28、数组去重（blog）</h3><h3 id="29、JS的7种基本数据类型"><a href="#29、JS的7种基本数据类型" class="headerlink" title="29、JS的7种基本数据类型"></a>29、JS的7种基本数据类型</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean、null、undefined、Number、String、Symbol(一种实例是唯一且不可改变的数据类型)、BigInt、Object</span><br></pre></td></tr></table></figure>

<h3 id="30、null和undefine的区别"><a href="#30、null和undefine的区别" class="headerlink" title="30、null和undefine的区别"></a>30、null和undefine的区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 JavaScript 中，null 和 undefined 是两种不同的特殊值，它们有着不同的含义和用法，下面是它们的区别：</span><br><span class="line"></span><br><span class="line">null：</span><br><span class="line"></span><br><span class="line">null 表示一个空值或者不存在的对象。</span><br><span class="line">当一个变量被赋值为 null 时，表示该变量的值为空。</span><br><span class="line">通常情况下，null 是由程序员显式地赋值给变量的，表示清空或者重置某个变量。</span><br><span class="line">例如，let myVar = null;</span><br><span class="line">undefined：</span><br><span class="line"></span><br><span class="line">undefined 表示一个未定义的值，即一个变量已经声明但没有被赋值。</span><br><span class="line">在 JavaScript 中，变量声明但未赋值时，默认值为 undefined。</span><br><span class="line">当访问一个未初始化的变量时，其值为 undefined。</span><br><span class="line">例如，let myVar; console.log(myVar); // 输出 undefined</span><br><span class="line">在使用上，null 通常表示主动赋值为空，而 undefined 表示变量未定义或者未初始化。另外，它们的数据类型也不同，null 是一个对象，而 undefined 是一个原始值。</span><br></pre></td></tr></table></figure>

<h3 id="31、ES6新增了那些数组方法（blog）"><a href="#31、ES6新增了那些数组方法（blog）" class="headerlink" title="31、ES6新增了那些数组方法（blog）"></a>31、ES6新增了那些数组方法（blog）</h3><h3 id="32、JS种常用容器的使用（blog）"><a href="#32、JS种常用容器的使用（blog）" class="headerlink" title="32、JS种常用容器的使用（blog）"></a>32、JS种常用容器的使用（blog）</h3><h3 id="33、DOM事件流（blog）"><a href="#33、DOM事件流（blog）" class="headerlink" title="33、DOM事件流（blog）"></a>33、DOM事件流（blog）</h3><h3 id="34、e-target和this的区别（blog）"><a href="#34、e-target和this的区别（blog）" class="headerlink" title="34、e.target和this的区别（blog）"></a>34、e.target和this的区别（blog）</h3><h3 id="35、阻止事件冒泡和默认行为（blog）"><a href="#35、阻止事件冒泡和默认行为（blog）" class="headerlink" title="35、阻止事件冒泡和默认行为（blog）"></a>35、阻止事件冒泡和默认行为（blog）</h3><h3 id="36、事件委托（blog）"><a href="#36、事件委托（blog）" class="headerlink" title="36、事件委托（blog）"></a>36、事件委托（blog）</h3><h3 id="37、this的指向问题（blog）"><a href="#37、this的指向问题（blog）" class="headerlink" title="37、this的指向问题（blog）"></a>37、this的指向问题（blog）</h3><h3 id="38、JS的执行机制（blog）"><a href="#38、JS的执行机制（blog）" class="headerlink" title="38、JS的执行机制（blog）"></a>38、JS的执行机制（blog）</h3><h3 id="39、JS事件循环-eventloop"><a href="#39、JS事件循环-eventloop" class="headerlink" title="39、JS事件循环(eventloop)"></a>39、JS事件循环(eventloop)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同步任务最先执行，由上到下执行的过程中如果遇到异步任务就放在 任务队列 最后排队，同步任务执行完成之后，优先执行所有的微任务，微任务执行完成之后，按顺序执行微任务，如此反复循环，事件循环。</span><br></pre></td></tr></table></figure>

<h3 id="40、宏任务和微任务（blog）"><a href="#40、宏任务和微任务（blog）" class="headerlink" title="40、宏任务和微任务（blog）"></a>40、宏任务和微任务（blog）</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">什么是宏任务什么是微任务？</span><br><span class="line">在 JavaScript 中，事件循环（Event Loop）是管理异步任务执行的机制。事件循环将任务分为两种类型：宏任务（MacroTask）和微任务（MicroTask）。</span><br><span class="line">宏任务（MacroTask）：</span><br><span class="line">宏任务代表着一个独立的、完整的执行单元，它可以包含多个子任务，例如：定时器回调函数、事件回调函数、IO 操作等。</span><br><span class="line">宏任务包括了整体代码块、setTimeout、setInterval、setImmediate、I/O、UI 渲染等任务。</span><br><span class="line">宏任务会被放入宏任务队列中等待执行，只有当执行栈为空时，事件循环才会从宏任务队列中选择一个宏任务执行。</span><br><span class="line">微任务（MicroTask）：</span><br><span class="line">微任务是相对于宏任务而言的，它是在当前任务执行结束后立即执行的任务。</span><br><span class="line">微任务包括了 Promise 回调函数和 MutationObserver 回调函数等。</span><br><span class="line">微任务会在当前任务执行完毕并将结果返回给调用者之后立即执行，而不需要等待宏任务队列中的其他任务执行完毕。</span><br><span class="line">微任务的执行时机在每个宏任务执行完成后，在下一个宏任务执行之前。</span><br><span class="line">事件循环的执行流程大致如下：</span><br><span class="line">执行一个宏任务（如执行整体代码、定时器回调等）。</span><br><span class="line">执行过程中，遇到微任务，将其添加到微任务队列中。</span><br><span class="line">当前宏任务执行完毕后，检查是否存在微任务队列，如果存在，则依次执行所有微任务。</span><br><span class="line">执行完所有微任务后，如果存在其他宏任务，从宏任务队列中选择一个宏任务继续执行，重复以上步骤。</span><br><span class="line">通过微任务和宏任务的结合，可以实现一些复杂的异步任务调度和控制逻辑，同时也能够确保任务的及时执行和顺序性。</span><br><span class="line"></span><br><span class="line">微任务的执行时机比微任务早</span><br><span class="line">常见宏任务：setTimeout, setInterval, DOM事件，AJAX请求</span><br><span class="line">常见微任务：Promise, async/await</span><br><span class="line">为什么宏任务比微任务先执行呢？</span><br><span class="line">微任务 先于 DOM渲染 先于 宏任务</span><br></pre></td></tr></table></figure>

<h3 id="41、原型和原型链（blog）"><a href="#41、原型和原型链（blog）" class="headerlink" title="41、原型和原型链（blog）"></a>41、原型和原型链（blog）</h3><h3 id="42、webSocket的基本使用-blog"><a href="#42、webSocket的基本使用-blog" class="headerlink" title="42、webSocket的基本使用(blog)"></a>42、webSocket的基本使用(blog)</h3><h3 id="43、什么是同步什么是异步以及二者的区别"><a href="#43、什么是同步什么是异步以及二者的区别" class="headerlink" title="43、什么是同步什么是异步以及二者的区别"></a>43、什么是同步什么是异步以及二者的区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常见的异步编程：</span><br><span class="line">fs文件操作：require(&#x27;fs&#x27;).readFile(&#x27;./index.html&#x27;, (err,data)=&gt;&#123;&#125;)</span><br><span class="line">数据库操作</span><br><span class="line">AJAX：$.get(&#x27;/server&#x27;, (data)=&gt;&#123;&#125;)</span><br><span class="line">定时器：setTimeout(()=&gt;&#123;&#125;, 2000)</span><br></pre></td></tr></table></figure>

<h3 id="44、生成随机数的函数"><a href="#44、生成随机数的函数" class="headerlink" title="44、生成随机数的函数"></a>44、生成随机数的函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成m~n的随机数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">rand</span>(<span class="params">m,n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (n-m) + m)<span class="comment">//常用</span></span><br><span class="line">    <span class="comment">/**或者</span></span><br><span class="line"><span class="comment">    return Math.floor(Math.random() * (n-m+1) + m)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="45、TCP和IP、三次握手四次挥手"><a href="#45、TCP和IP、三次握手四次挥手" class="headerlink" title="45、TCP和IP、三次握手四次挥手"></a>45、TCP和IP、三次握手四次挥手</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TCP（Transmission Control Protocol，传输控制协议）和 IP（Internet Protocol，互联网协议）是互联网中两个重要的网络协议，它们共同构成了TCP/IP协议栈，用于实现网络通信。</span><br><span class="line"></span><br><span class="line">IP（Internet Protocol）：</span><br><span class="line"></span><br><span class="line">IP 是一种网络层协议，负责在网络中传输数据包。</span><br><span class="line">IP 协议使用 IP 地址来唯一标识网络中的设备，通过路由器将数据包从源地址传输到目标地址。</span><br><span class="line">IP 协议是不可靠的，它只负责数据包的传输，不保证数据包的可靠性、顺序性和完整性。</span><br><span class="line">TCP（Transmission Control Protocol）：</span><br><span class="line"></span><br><span class="line">TCP 是一种传输层协议，建立在 IP 协议之上，提供可靠的、面向连接的通信服务。</span><br><span class="line">TCP 协议通过三次握手来建立连接，四次挥手来释放连接，保证数据传输的可靠性和顺序性。</span><br><span class="line">TCP 协议提供了流量控制、拥塞控制、重传机制等功能，确保数据的可靠传输。</span><br><span class="line">下面是 TCP 连接的建立（三次握手）和释放（四次挥手）过程：</span><br><span class="line"></span><br><span class="line">三次握手（TCP 连接建立）：</span><br><span class="line"></span><br><span class="line">1.1.客户端发送 SYN（同步）报文给服务器，并进入 SYN_SENT 状态。</span><br><span class="line">1.2.服务器收到 SYN 报文后，返回 SYN+ACK（同步确认）报文给客户端，并进入 SYN_RECV 状态。</span><br><span class="line">1.3.客户端收到 SYN+ACK 报文后，发送 ACK（确认）报文给服务器，完成三次握手，建立连接，并进入 ESTABLISHED 状态。</span><br><span class="line">四次挥手（TCP 连接释放）：</span><br><span class="line"></span><br><span class="line">2.1.客户端发送 FIN（结束）报文给服务器，并进入 FIN_WAIT_1 状态。</span><br><span class="line">2.2.服务器收到 FIN 报文后，返回 ACK 报文给客户端，并进入 CLOSE_WAIT 状态。</span><br><span class="line">2.3.服务器处理完数据后，发送 FIN 报文给客户端，并进入 LAST_ACK 状态。</span><br><span class="line">2.4.客户端收到 FIN 报文后，返回 ACK 报文给服务器，进入 TIME_WAIT 状态，等待 2MSL（最长报文段寿命） 后，进入 CLOSED 状态。</span><br><span class="line">2.5.服务器收到 ACK 报文后，进入 CLOSED 状态。</span><br><span class="line">通过三次握手建立连接和四次挥手释放连接，TCP 协议确保了数据的可靠传输和连接的可靠建立和释放。</span><br></pre></td></tr></table></figure>

<h3 id="46、浏览器的渲染原理"><a href="#46、浏览器的渲染原理" class="headerlink" title="46、浏览器的渲染原理"></a>46、浏览器的渲染原理</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">浏览器的渲染过程涉及多个步骤，包括从服务器获取HTML、解析HTML、构建DOM树、构建渲染树、布局（Layout）和绘制（Painting）等。以下是浏览器渲染的基本流程：</span><br><span class="line"></span><br><span class="line">1.获取HTML： 浏览器通过网络请求从服务器获取 HTML 文件。</span><br><span class="line"></span><br><span class="line">2.解析HTML： 浏览器将获取到的 HTML 文件解析成 DOM 树（Document Object Model，文档对象模型），DOM 树表示了 HTML 文档的结构和内容。</span><br><span class="line"></span><br><span class="line">3.构建渲染树： 浏览器根据 DOM 树构建渲染树（Render Tree），渲染树是由 DOM 树中的可见元素（如 div、span、img 等）和 CSS 样式表中的样式信息组成的，它忽略了不可见的元素（如 head、script 等）和设置了 display: none 的元素。</span><br><span class="line"></span><br><span class="line">4.布局（Layout）： 浏览器计算渲染树中每个元素在页面中的位置和大小，这个过程称为布局或回流（Reflow）。布局过程涉及到页面中的盒模型、浮动、定位、文本方向等属性的计算，以及页面的自适应和响应式布局等。</span><br><span class="line"></span><br><span class="line">5.绘制（Painting）： 浏览器使用布局阶段计算得到的位置和大小信息，将渲染树中的每个元素转换成页面上的实际像素，绘制在屏幕上。这个过程称为绘制或重绘（Repaint），涉及到页面的像素填充、边框绘制、文本渲染等。</span><br><span class="line"></span><br><span class="line">6.合成（Composite）： 最后，浏览器将绘制好的图层按照合适的顺序合成到页面的显示缓冲区中，生成最终的页面视图。这个过程称为合成或合成器（Compositor）。</span><br><span class="line"></span><br><span class="line">以上是浏览器渲染的基本流程，不同浏览器可能会有一些优化和特殊的处理方式，但整体的渲染原理大致相同。渲染过程的优化和提升对于页面的性能和用户体验至关重要，因此开发者需要在编写代码时注意页面的结构、样式和脚本的性能，以便提高页面的渲染速度和流畅度。</span><br></pre></td></tr></table></figure>

<h3 id="47、什么是MVVM、MVC模型"><a href="#47、什么是MVVM、MVC模型" class="headerlink" title="47、什么是MVVM、MVC模型"></a>47、什么是MVVM、MVC模型</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MVVM（Model-View-ViewModel）和 MVC（Model-View-Controller）是两种常见的软件架构模式，用于组织和管理应用程序的结构。它们都将应用程序分成三个主要部分：模型（Model）、视图（View）和控制器（Controller）或视图模型（ViewModel），但它们在设计和实现上有所不同。</span><br><span class="line"></span><br><span class="line">MVC（Model-View-Controller）模型：</span><br><span class="line"></span><br><span class="line">MVC 是一种基于分层的软件架构模式，将应用程序分成三个独立的部分：模型（Model）、视图（View）和控制器（Controller）。</span><br><span class="line">模型（Model）负责存储数据和业务逻辑，提供对数据的操作接口。</span><br><span class="line">视图（View）负责展示用户界面，并将用户的操作传递给控制器。</span><br><span class="line">控制器（Controller）负责接收用户的输入，处理用户的请求，调用模型进行数据操作，并更新视图。</span><br><span class="line">控制器充当了模型和视图之间的中介，将两者解耦，提高了代码的可维护性和可测试性。</span><br><span class="line">MVVM（Model-View-ViewModel）模型：</span><br><span class="line"></span><br><span class="line">MVVM 是一种基于数据绑定的软件架构模式，它是在 MVC 模式的基础上演变而来的。</span><br><span class="line">MVVM 将应用程序分成三个部分：模型（Model）、视图（View）和视图模型（ViewModel）。</span><br><span class="line">模型（Model）和 MVC 中的模型相同，负责存储数据和业务逻辑。</span><br><span class="line">视图（View）和 MVC 中的视图相同，负责展示用户界面。</span><br><span class="line">视图模型（ViewModel）是 MVVM 中的新角色，它是视图的抽象，负责封装视图的状态和行为，并与模型进行交互。视图模型通过数据绑定将视图与模型解耦，使视图的更新更加简洁和高效。</span><br><span class="line">MVVM 中的视图模型充当了控制器的角色，但它与视图紧密绑定，能够更好地处理视图中的逻辑和状态。</span><br><span class="line">总的来说，MVC 模式强调分层和分离，而 MVVM 模式强调数据绑定和视图模型。选择合适的模式取决于应用程序的复杂度、团队的技术水平和个人的偏好。</span><br></pre></td></tr></table></figure>

<h3 id="48、Vue双向数据绑定的原理"><a href="#48、Vue双向数据绑定的原理" class="headerlink" title="48、Vue双向数据绑定的原理"></a>48、Vue双向数据绑定的原理</h3><h3 id="49、Vue的生命周期有哪些-blog"><a href="#49、Vue的生命周期有哪些-blog" class="headerlink" title="49、Vue的生命周期有哪些(blog)"></a>49、Vue的生命周期有哪些(blog)</h3><h3 id="50、常见的数组方法有哪些"><a href="#50、常见的数组方法有哪些" class="headerlink" title="50、常见的数组方法有哪些"></a>50、常见的数组方法有哪些</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</span><br><span class="line">find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined 。</span><br><span class="line">findIndex() 方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。</span><br><span class="line">includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true， 否则返回 false。</span><br><span class="line">indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 （通常用它判断数组中有没有这个元素）</span><br><span class="line">join() 方法将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。 如果数组只有一个项目，那么将返回该项目而不使用分隔符。</span><br><span class="line">pop() 方法从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</span><br><span class="line">push() 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</span><br><span class="line">shift() 方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。</span><br><span class="line">unshift() 方法将一个或多个元素添加到数组的开头，并返回该数组的新长度(该方法修改原有数组)。</span><br><span class="line">splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内 容。此方法会改变原数组。 由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删 除元素，则返回空数组。</span><br><span class="line">slice() 方法同上，但不会改变原数组</span><br><span class="line">reverse() 方法将数组中元素的位置颠倒，并返回该数组。该方法会改变原数组。</span><br><span class="line">sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字 符串，然后比较它们的 UTF-16 代码单元值序列时构建的</span><br></pre></td></tr></table></figure>

<h3 id="51、什么是原型链"><a href="#51、什么是原型链" class="headerlink" title="51、什么是原型链"></a>51、什么是原型链</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个实例对象上有一个proto 属性，指向的构造函数的原型对象，构造函数的原型 对象也是一个对象， 也有 proto 属性，这样一层一层往上找的过程就形成了原型链。</span><br></pre></td></tr></table></figure>

<h3 id="52、常见的继承有哪些"><a href="#52、常见的继承有哪些" class="headerlink" title="52、常见的继承有哪些"></a>52、常见的继承有哪些</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">一、原型链继承</span><br><span class="line">特点：  1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新 实例不会继承父类实例的属性！</span><br><span class="line">缺点：  1、新实例无法向父类构造函数传参。</span><br><span class="line">2、继承单一。</span><br><span class="line">3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属 性，另一个实例的原 型属性也会被修改！）</span><br><span class="line">二、借用构造函数继承</span><br><span class="line">重点：  用 .call()和.apply() 将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复 制））</span><br><span class="line">特点：  1、只继承了父类构造函数的属性，没有继承父类原型的属性。</span><br><span class="line">2、解决了原型链继承缺点 1、2、3。</span><br><span class="line">3、可以继承多个构造函数属性（call 多个）。</span><br><span class="line">4、在子实例中可向父实例传参。</span><br><span class="line">缺点：  1、只能继承父类构造函数的属性。</span><br><span class="line">2、无法实现构造函数的复用。（每次用每次都要重新调用）</span><br><span class="line">3、每个新实例都有父类构造函数的副本，臃肿。</span><br><span class="line">三、组合继承（组合原型链继承和借用构造函数继承）（常用）</span><br><span class="line">重点： 结合了两种模式的优点，传参和复用</span><br><span class="line">特点：  1、可以继承父类原型上的属性，可以传参，可复用。</span><br><span class="line">2、每个新实例引入的构造函数属性是私有的。</span><br><span class="line">缺点： 调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函 数。</span><br><span class="line">四、原型式继承</span><br><span class="line">重点： 用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的 实例或对象。object.create()就是这个原理。</span><br><span class="line">特点： 类似于复制一个对象，用函数来包装。</span><br><span class="line">缺点： 1、所有实例都会继承原型上的属性。 2、无法实现复用。（新实例属性都是后面添加的）</span><br><span class="line">五、class 类实现继承</span><br><span class="line">通过 extends 和 super 实现继承</span><br><span class="line">六、寄生式继承</span><br><span class="line">重点： 就是给原型式继承外面套了个壳子。</span><br><span class="line">优点： 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成 了创建的新对象。</span><br><span class="line">缺点： 没用到原型，无法复用。</span><br></pre></td></tr></table></figure>

<h3 id="53、后台管理系统中的权限管理是怎么实现的？"><a href="#53、后台管理系统中的权限管理是怎么实现的？" class="headerlink" title="53、后台管理系统中的权限管理是怎么实现的？"></a>53、后台管理系统中的权限管理是怎么实现的？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">登录： 当用户填写完账号和密码后向服务端验证是否正确，验证通过之后，服务端会返回一个 token，</span><br><span class="line">拿到 token 之后（我会将这个 token 存贮到 cookie 中，保证刷新页面后能记住用户登录状态），前端会 根据 token 再去拉取一个 user_info 的接口来获取用户的详细信息（如用户权限，用户名等等信息）。</span><br><span class="line">权限验证： 通过 token 获取用户对应的 权限，动态根据用户的 权限算出其对应有权限的路由，通过 router.addRoutes 动态挂载这些路由。</span><br><span class="line">具体思路：</span><br><span class="line">登录成功后，服务端会返回一个 token（该 token 的是一个能唯一标示用户身份的一个 key），之后我 们将 token 存储在本地 cookie 之中，这样下次打开页面或者刷新页面的时候能记住用户的登录状态，不 用再去登录页面重新登录了。</span><br><span class="line">ps:为了保证安全性，我司现在后台所有 token 有效期(Expires/Max-Age)都是 Session，就是当浏览器关 闭了就丢失了。重新打开游览器都需要重新登录验证，后端也会在每周固定一个时间点重新刷新 token，让后台用户全部重新登录一次，确保后台用户不会因为电脑遗失或者其它原因被人随意使用账 号。</span><br><span class="line">用户登录成功之后，我们会在全局钩子 router.beforeEach 中拦截路由，判断是否已获得 token，在 获得 token 之后我们就要去获取用户的基本信息了 页面会先从 cookie 中查看是否存有 token，没有，就走一遍上一部分的流程重新登录，如果有 token, 就会把这个 token 返给后端去拉取 user_info，保证用户信息是最新的。 当然如果是做了单点登录得功 能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登 录获取最新的内容。</span><br><span class="line">先说一说我权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登 录之后，通过 token 获取用户的 role ，动态根据用户的 role 算出其对应有权限的路由，再通过 router.addRoutes 动态挂载路由。但这些控制都只是页面级的，说白了前端再怎么做权限控制都不是 绝对安全的，后端的权限验证是逃不掉的。</span><br><span class="line">我司现在就是前端来控制页面级的权限，不同权限的用户显示不同的侧边栏和限制其所能进入的页面(也 做了少许按钮级别的权限控制)，后端则会验证每一个涉及请求的操作，验证其是否有该操作的权限，每 一个后台的请求不管是 get 还是 post 都会让前端在请求 header 里面携带用户的 token，后端会根据 该 token 来验证用户是否有权限执行该操作。若没有权限则抛出一个对应的状态码，前端检测到该状 态码，做出相对应的操作。 使用 vuex 管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件。</span><br><span class="line">具体实现：</span><br><span class="line">创建 vue 实例的时候将vue-router挂载，但这个时候 vue-router 挂载一些登录或者不用权限的公用的页 面。</span><br><span class="line">当用户登录后，获取用role，将 role 和路由表每个页面的需要的权限作比较，生成最终用户可访问的路 由表。</span><br><span class="line">调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。</span><br><span class="line">使用vuex管理路由表，根据 vuex 中可访问的路由渲染侧边栏组件。</span><br></pre></td></tr></table></figure>

<h3 id="54、es6-有哪些新特性？"><a href="#54、es6-有哪些新特性？" class="headerlink" title="54、es6 有哪些新特性？"></a>54、es6 有哪些新特性？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ES6 是 2015 年推出的一个新的版本、这个版本相对于 ES5 的语法做了很多的优化、例如：新增了let、 const</span><br><span class="line">let 和 const具有块级作用域，不存在变量提升的问题。新增了箭头函数，简化了定义函数的写法，</span><br><span class="line">同时 可以巧用箭头函数的 this、（注意箭头函数本身没有 this,它的 this 取决于外部的环境），</span><br><span class="line">新增了promise 解决了回调地域的问题，新增了模块化、利用 import 、export 来实现导入、导出。</span><br><span class="line">新增了结构赋值， ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</span><br><span class="line">新增了class 类的概念，它类似于对象。</span><br></pre></td></tr></table></figure>

<h3 id="55、v-for-循环为什么一定要绑定-key"><a href="#55、v-for-循环为什么一定要绑定-key" class="headerlink" title="55、v-for 循环为什么一定要绑定 key ?"></a>55、v-for 循环为什么一定要绑定 key ?</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象), 循环中 ,如果没有唯一 key , 页面上删除 一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为 x 标签被删除 掉, 只需要把渲染的 dom 为 x 的标签去掉即可!</span><br></pre></td></tr></table></figure>

<h3 id="56、平时都是用什么实现跨域的？"><a href="#56、平时都是用什么实现跨域的？" class="headerlink" title="56、平时都是用什么实现跨域的？"></a>56、平时都是用什么实现跨域的？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsonp: 利用 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一 定需要对方的服务器做支持才可以。</span><br><span class="line">JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具 有局限性,不安全可能会遭受 XSS 攻击。</span><br><span class="line">声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获 取目标数据(服务器返回的 data)。 创建一个 &lt;script&gt; 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服 务器传递该函数名（可以通过问号传参:?callback=show）。</span><br><span class="line">服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符 串,例如：传递进去的函数名是 show，它准备好的数据是 show(&#x27;我不爱你&#x27;) 。</span><br><span class="line">最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数 （show），对返回的数据进行操作。</span><br><span class="line">CORS：跨域资源共享（CORS）是一种机制；当一个资源访问到另外一个资源(这个资源放在 不同的域名或者不同的协议或者端口)，资源就会发起一个跨域的 HTTP 请求需要浏览器和服务器同时支持；</span><br><span class="line">1.整个 CORS 通信，都是浏览器自动完成。浏览器发现了 AJAX 请求跨源，就会自动添加一些附加的头 信息，有时还会多出一次附加的请求，但用户不会有感觉；</span><br><span class="line">2.实现 CORS 的关键是服务器，只要服务器实现了 CORS 接口，就可以跨源通信</span><br><span class="line">3.服务器对于不同的请求，处理方式不一样； 有简单请求和非简单请求</span><br></pre></td></tr></table></figure>

<h3 id="57、this-的指向有哪些？"><a href="#57、this-的指向有哪些？" class="headerlink" title="57、this 的指向有哪些？"></a>57、this 的指向有哪些？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、普通函数中的 this 指向 window</span><br><span class="line">2、定时器中的 this 指向 window</span><br><span class="line">3、箭头函数没有 this,它的 this 指向取决于外部环境、</span><br><span class="line">4、事件中的 this 指向事件的调用者 黑马程序员</span><br><span class="line">5、 构造函数中 this 和原型对象中的 this,都是指向构造函数 new 出来实例对象</span><br><span class="line">6、类 class 中的 this 指向由 constructor 构造器 new 出来的实例对象</span><br><span class="line">7、自调用函数中的 this 指向 window</span><br></pre></td></tr></table></figure>

<h3 id="58、谈谈你平时都用了哪些方法进行性能优化？"><a href="#58、谈谈你平时都用了哪些方法进行性能优化？" class="headerlink" title="58、谈谈你平时都用了哪些方法进行性能优化？"></a>58、谈谈你平时都用了哪些方法进行性能优化？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">减少 http 请求次数、打包压缩上线代码、使用懒加载、使用雪碧图、动态渲染组件、CDN 加载包。</span><br></pre></td></tr></table></figure>

<h3 id="59、vue-实例是挂载到那个标签上的？"><a href="#59、vue-实例是挂载到那个标签上的？" class="headerlink" title="59、vue 实例是挂载到那个标签上的？"></a>59、vue 实例是挂载到那个标签上的？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue 实例最后会挂载在body 标签里面，所以我们在 vue 中是获取不了 body 标签的，如果要使用 body 标 签的话需要用原生的方式获取</span><br></pre></td></tr></table></figure>

<h3 id="60、请写至少三种数组去重的方法？（原生-js）"><a href="#60、请写至少三种数组去重的方法？（原生-js）" class="headerlink" title="60、请写至少三种数组去重的方法？（原生 js）"></a>60、请写至少三种数组去重的方法？（原生 js）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用filter</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">//当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item, <span class="number">0</span>) === index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用ES6 Set去重（ES6中最常用）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;&#125;, &#123;&#125;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用for嵌套for，然后splice去重（ES5中最常用）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        <span class="comment">//第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>)</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="literal">true</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="title class_">NaN</span>,</span><br><span class="line">  <span class="string">&#x27;NaN&#x27;</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">unique</span>(arr))</span><br><span class="line"><span class="comment">//[1, &quot;true&quot;, 15, false, undefined, NaN, NaN, &quot;NaN&quot;, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">//NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br></pre></td></tr></table></figure>

<h3 id="61、请写出至少两种常见的数组排序的方法（原生-js）"><a href="#61、请写出至少两种常见的数组排序的方法（原生-js）" class="headerlink" title="61、请写出至少两种常见的数组排序的方法（原生 js）"></a>61、请写出至少两种常见的数组排序的方法（原生 js）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">elements</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elements.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> elements</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pivotIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(elements.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> pivot = elements.<span class="title function_">splice</span>(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> left = []</span><br><span class="line">  <span class="keyword">var</span> right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (elements[i] &lt; pivot) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(elements[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(elements[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>([pivot], <span class="title function_">quickSort</span>(right))</span><br><span class="line">  <span class="comment">//concat()方法用于连接两个或者多个数组；该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="title function_">quickSort</span>(elements))</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">elements</span>) &#123;</span><br><span class="line">  <span class="comment">// 假设第0个元素是一个有序数列，第1个以后的是无序数列，</span></span><br><span class="line">  <span class="comment">// 所以从第1个元素开始将无序数列的元素插入到有序数列中去</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= elements.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 升序</span></span><br><span class="line">    <span class="keyword">if</span> (elements[i] &lt; elements[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">// 取出无序数列中的第i个作为被插入元素</span></span><br><span class="line">      <span class="keyword">var</span> guard = elements[i]</span><br><span class="line">      <span class="comment">//记住有序数列的最后一个位置，并且将有序数列的位置扩大一个</span></span><br><span class="line">      <span class="keyword">var</span> j = i - <span class="number">1</span></span><br><span class="line">      elements[i] = elements[j]</span><br><span class="line">      <span class="comment">// 比大小;找到被插入元素所在位置</span></span><br><span class="line">      <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; guard &lt; elements[j]) &#123;</span><br><span class="line">        elements[j + <span class="number">1</span>] = elements[j]</span><br><span class="line">        j--</span><br><span class="line">      &#125;</span><br><span class="line">      elements[j + <span class="number">1</span>] = guard <span class="comment">//插入</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;没调用之前：&#x27;</span> + elements)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;br&gt;&#x27;</span>)</span><br><span class="line"><span class="title function_">sort</span>(elements)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;被调用之后：&#x27;</span> + elements)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">elements</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; elements.<span class="property">length</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elements[j] &gt; elements[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">var</span> swap = elements[j]</span><br><span class="line">        elements[j] = elements[j + <span class="number">1</span>]</span><br><span class="line">        elements[j + <span class="number">1</span>] = swap</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elements = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;before&#x27;</span> + elements)</span><br><span class="line"><span class="title function_">sort</span>(elements)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span> + elements)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br></pre></td></tr></table></figure>

<h3 id="62、清除浮动的方法有哪些？"><a href="#62、清除浮动的方法有哪些？" class="headerlink" title="62、清除浮动的方法有哪些？"></a>62、清除浮动的方法有哪些？</h3><p>为什么要清除浮动，因为浮动的盒子脱离标准流，如果父盒子没有设置高度的话，下面的盒子就会撑上 来。</p>
<p>1.额外标签法（在最后一个浮动标签后，新加一个标签，给其设置 clear：both；）（不推荐）</p>
<p>2.父级添加 overflow 属性（父元素添加 overflow:hidden）（不推荐）</p>
<p><strong>3.使用 after 伪元素清除浮动（推荐使用）</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="comment">/*伪元素是行内元素 正常浏览器清除浮动方法*/</span></span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;<span class="comment">/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><strong>4.使用 before 和 after 双伪元素清除浮动</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="63、ES6中的class类"><a href="#63、ES6中的class类" class="headerlink" title="63、ES6中的class类"></a>63、ES6中的class类</h3><blockquote>
</blockquote>
<p>在 ES6 中，引入了 <code>class</code> 关键字，使得 JavaScript 可以更加方便地实现面向对象编程（OOP）的特性。<code>class</code> 关键字提供了一种更加简洁、清晰的语法来定义类和创建对象，它是一种语法糖，基于原型继承的底层机制。</p>
<p>下面是使用 <code>class</code> 关键字定义类的基本语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">parameters</span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数，在创建对象时调用，用于初始化对象的状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">property</span> = parameters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">method1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类方法</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">method2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 类方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>class</code> 关键字用于定义一个类，类名通常采用大驼峰命名规范。</li>
<li><code>constructor</code> 方法是一个特殊的方法，在创建对象时被调用，用于初始化对象的状态，可以接收参数。</li>
<li>类中的方法可以直接定义在类体内，方法之间不需要使用逗号分隔。</li>
<li>使用 <code>new</code> 关键字和类名可以创建类的实例对象，调用构造函数初始化对象的状态。</li>
<li>类方法可以直接在实例对象上调用，用于操作实例对象的状态和行为。</li>
</ul>
<p>除了构造函数和普通方法之外，类还支持静态方法（static methods）和 getter&#x2F;setter（存取器），用于定义与类本身关联的方法和属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_name</span> = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>._age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">30</span>);</span><br><span class="line">person.<span class="title function_">sayHello</span>(); <span class="comment">// 输出: Hello, my name is Alice and I&#x27;m 30 years old.</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">greet</span>(); <span class="comment">// 输出: Hello!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上面的示例中，<code>Person</code> 类定义了一个构造函数和两个实例方法（<code>sayHello</code>）、一个静态方法（<code>greet</code>）、一个 getter 和一个 setter。可以通过 <code>new</code> 关键字创建 <code>Person</code> 类的实例对象，并调用实例方法和静态方法。</p>
</blockquote>
<h3 id="64、谈谈盒子模型？"><a href="#64、谈谈盒子模型？" class="headerlink" title="64、谈谈盒子模型？"></a>64、谈谈盒子模型？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。</span><br><span class="line">增加内边距、边框和外边距不会 影响内容区域的尺寸，但是会增加元素框的总尺寸。</span><br><span class="line">IE 盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。</span><br></pre></td></tr></table></figure>

<h3 id="65、箭头函数有哪些特征，请简单描述一下它？"><a href="#65、箭头函数有哪些特征，请简单描述一下它？" class="headerlink" title="65、箭头函数有哪些特征，请简单描述一下它？"></a>65、箭头函数有哪些特征，请简单描述一下它？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">箭头函数没有自己的 this，this 指向定义箭头函数时所处的外部执行环境的 this</span><br><span class="line">即使调用call/apply/bind也无法改变箭头函数的 this 箭头函数本身没有名字 箭头函数不能 new，会报错</span><br><span class="line">箭头函数没有 arguments，在箭头函数内访问这个变量访问的是外部执行环境的 arguments 箭头函数没有 prototype</span><br></pre></td></tr></table></figure>

<h3 id="66、移动端点击事件的300ms延迟的问题-blog"><a href="#66、移动端点击事件的300ms延迟的问题-blog" class="headerlink" title="66、移动端点击事件的300ms延迟的问题(blog)"></a>66、移动端点击事件的300ms延迟的问题(blog)</h3><h3 id="67、什么是同源策略？"><a href="#67、什么是同源策略？" class="headerlink" title="67、什么是同源策略？"></a>67、什么是同源策略？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓同源策略是浏览器的一种安全机制，来限制不同源的网站不能通信。同源就是域名、协议、端口一 致。</span><br></pre></td></tr></table></figure>

<h3 id="68、http-状态码分别代表什么意思？"><a href="#68、http-状态码分别代表什么意思？" class="headerlink" title="68、http 状态码分别代表什么意思？"></a>68、http 状态码分别代表什么意思？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx 表示 HTTP 请求已经接受，继续处理请求</span><br><span class="line">2xx 表示 HTTP 请求已经处理完成(200)</span><br><span class="line">3xx 表示把请求访 问的 URL 重定向到其他目录(304 资源没有发生变化，会重定向到本地资源)</span><br><span class="line">4xx 表示客户端出现错误 (403 禁止访问、404 资源不存在)</span><br><span class="line">5xx 表示服务端出现错误</span><br></pre></td></tr></table></figure>

<h3 id="69、安全问题-：CSRF-和-XSS-攻击？"><a href="#69、安全问题-：CSRF-和-XSS-攻击？" class="headerlink" title="69、安全问题 ：CSRF 和 XSS 攻击？"></a>69、安全问题 ：CSRF 和 XSS 攻击？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CSRF （ Cross-site request forgery ）：跨站请求伪造。</span><br><span class="line">方法一、Token 验证：（用的最多）</span><br><span class="line"></span><br><span class="line">服务器发送给客户端一个 token ；</span><br><span class="line">客户端提交的表单中带着这个 token 。</span><br><span class="line">如果这个 token 不合法，那么服务器拒绝这个请求。</span><br><span class="line"></span><br><span class="line">方法二：隐藏令牌：</span><br><span class="line">把 token 隐藏在 http 的 head 头中。</span><br><span class="line">方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</span><br><span class="line">方法三、Referer 验证：</span><br><span class="line">Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；</span><br><span class="line">如果不是，就拦截  XSS（Cross Site Scripting）：跨域脚本攻击。</span><br><span class="line">1.编码：</span><br><span class="line">对用户输入的数据进行 HTML Entity 编码。 如上图所示，把字符转换成 转义字符。 Encode 的作用是将 $var`等一些字符进行转化，使得浏览器在最终输出结果上是一样的</span><br><span class="line"></span><br><span class="line">若不进行任何处理，则浏览器会执行 alert 的 js 操作，实现 XSS 注入。进行编码处理之后，L 在浏览</span><br><span class="line">器中的显示结果就是 &lt;script&gt;alert(1)&lt;/script&gt; ，实现了将 `$var 作为纯文本进行输出，且</span><br><span class="line">不引起 J avaScript 的执行。</span><br><span class="line"></span><br><span class="line">2.过滤：</span><br><span class="line">移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。（总而言是，过滤掉一些不安全的内容）</span><br><span class="line">移除用户输入的 Style 节点、 Script 节点、 Iframe 节点。（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）。</span><br><span class="line">3.校正：</span><br><span class="line">避免直接对 HTML Entity 进行解码。</span><br><span class="line">使用 DOM Parse 转换，校正不配对的 DOM 标签。</span><br><span class="line">备注： 我们应该去了解一下 DOM Parse 这个概念，它的作用是把文本解析成 DOM 结构。 比较常用的做法是，通过第一步的编码转成文本，然后第三步转成 DOM 对象，然后经过第二步的过滤。</span><br></pre></td></tr></table></figure>

<h3 id="70、CSRF-和-XSS-的区别"><a href="#70、CSRF-和-XSS-的区别" class="headerlink" title="70、CSRF 和 XSS 的区别"></a>70、CSRF 和 XSS 的区别</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">区别一：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSRF ：需要用户先登录网站 A ，获取 cookie</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XSS ：不需要登录。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">区别二：（原理的区别）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CSRF ：是利用网站 A 本身的漏洞，去请求网站 A 的 api 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XSS ：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</span><br></pre></td></tr></table></figure>

<h3 id="71、call-apply-bind-三者的异同"><a href="#71、call-apply-bind-三者的异同" class="headerlink" title="71、call  apply  bind 三者的异同"></a>71、call  apply  bind 三者的异同</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">共同点 : 都可以改变 this 指向;</span><br><span class="line">不同点: call 和 apply 会调用函数, 并且改变函数内部 this 指向. call 和 apply传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递 bind 不会调用函数, 可以改变函 数内部 this 指向. 应用场景</span><br><span class="line">call 经常做继承.</span><br><span class="line">apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</span><br><span class="line">bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向</span><br></pre></td></tr></table></figure>

<h3 id="72、状态码304"><a href="#72、状态码304" class="headerlink" title="72、状态码304"></a>72、状态码304</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制。当客户端再次请求页面时，服务器会判断请求的页面是否已被缓存，若已经被缓存则返回304，此时客户端将调用缓存内容。</span><br><span class="line"></span><br><span class="line">状态码304不应该被认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。</span><br><span class="line"></span><br><span class="line">产生较多304状态码的原因是什么？</span><br><span class="line">页面更新周期长或者长时间未更新</span><br><span class="line">纯静态页面或强制生成静态HTML</span><br><span class="line">304状态码过多会造成什么问题？</span><br><span class="line">网站快照停止</span><br><span class="line">收录减少</span><br><span class="line">权重下降</span><br></pre></td></tr></table></figure>

<h3 id="73、exports-module-exports和JS模块加载机制（blog）"><a href="#73、exports-module-exports和JS模块加载机制（blog）" class="headerlink" title="73、exports  module.exports和JS模块加载机制（blog）"></a>73、exports  module.exports和JS模块加载机制（blog）</h3><h3 id="74、运算规则"><a href="#74、运算规则" class="headerlink" title="74、运算规则"></a>74、运算规则</h3>
<div class="markmap-container" style="height:250px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;运算规则&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,6]},&quot;v&quot;:&quot;算数运算&lt;br&gt;\n+-*/%&lt;br&gt;\n++ --&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;转换为数字，然后运算&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;特殊情况：x+y，x和y有一个是字符串。转换为字符串，然后拼接&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;特殊情况：NaN和任何类型运算得到的还是NaN&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,15]},&quot;v&quot;:&quot;比较运算&lt;br&gt;\n&amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&lt;br&gt;\n== !=&lt;br&gt;\n=== !==&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;&lt;strong&gt;转换成原始类型&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;转换为数字然后比较&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;特殊情况：两端全是字符串，比较字典顺序&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;特殊情况：两端都存在NaN,一定为false&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;&lt;strong&gt;===&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;类型和值必须都相同&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;特殊情况：两端存在NaN，一定为false&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;&lt;strong&gt;==&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;两端类型相同，比较值&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;两端都是原始类型，转换成数字比较&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;一端是原始类型，一端是对象类型，把对象转换成原始类型后比较&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;特殊情况：undefined和null只有与自身比较，或者互相比较时，才会返回true&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;特殊情况：两端存在NaN，一定为false&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;&lt;strong&gt;!= !==&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;对相等取反&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[30,33]},&quot;v&quot;:&quot;逻辑运算&lt;br&gt;\n！ &amp;amp;&amp;amp; ||&lt;br&gt;\n？:&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[33,34]},&quot;v&quot;:&quot;&lt;strong&gt;转换为boolean&lt;/strong&gt;&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[34,35]},&quot;v&quot;:&quot;x &amp;amp;&amp;amp; y&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[35,36]},&quot;v&quot;:&quot;x为false,返回x&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[36,37]},&quot;v&quot;:&quot;x为true,返回y&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[37,38]},&quot;v&quot;:&quot;x || y&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[38,39]},&quot;v&quot;:&quot;x为false,返回y&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[39,40]},&quot;v&quot;:&quot;x为true,返回x&quot;}]}]}]}]}"></svg>
</div>


<h3 id="75、类型转换（npm-install-hexo-markmap）"><a href="#75、类型转换（npm-install-hexo-markmap）" class="headerlink" title="75、类型转换（npm install hexo-markmap）"></a>75、类型转换（npm install hexo-markmap）</h3>
<div class="markmap-container" style="height:250px">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;类型转换&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;原始 -&amp;gt; 数字&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;true: 1&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;false: 0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;null: 0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;undefined: NaN&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;string&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;空字符串（含空白字符）：0&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;去掉引号，不是数字就是NaN&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;所有 -&amp;gt; bool&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;null: false&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;undefined: false&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;number&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;0: false&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;NaN: false&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;其他：true&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;string&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;空字符串：false&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[20,21]},&quot;v&quot;:&quot;其他：true&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[21,22]},&quot;v&quot;:&quot;对象：true&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[22,23]},&quot;v&quot;:&quot;原始 -&amp;gt; 字符串&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[23,24]},&quot;v&quot;:&quot;null: &amp;quot;null&amp;quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[24,25]},&quot;v&quot;:&quot;undefined: &amp;quot;undefined&amp;quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[25,26]},&quot;v&quot;:&quot;number: &amp;quot;数字&amp;quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[26,27]},&quot;v&quot;:&quot;boolean&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[27,28]},&quot;v&quot;:&quot;true: &amp;quot;true&amp;quot;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[28,29]},&quot;v&quot;:&quot;false: &amp;quot;false&amp;quot;&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[29,30]},&quot;v&quot;:&quot;对象 -&amp;gt; 原始&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[30,31]},&quot;v&quot;:&quot;调用valueOf&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[31,32]},&quot;v&quot;:&quot;得到的是对象？重新调用toString&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:9,&quot;p&quot;:{&quot;lines&quot;:[32,33]},&quot;v&quot;:&quot;得到的还是对象？报错&quot;}]}]}]}]}"></svg>
</div>


<h3 id="76、移动端和PC端如何实现屏幕适配"><a href="#76、移动端和PC端如何实现屏幕适配" class="headerlink" title="76、移动端和PC端如何实现屏幕适配"></a>76、移动端和PC端如何实现屏幕适配</h3><h4 id="移动端屏幕适配："><a href="#移动端屏幕适配：" class="headerlink" title="移动端屏幕适配："></a>移动端屏幕适配：</h4><ol>
<li><p><strong>Viewport Meta标签：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个标签告诉浏览器使用设备的宽度作为视口宽度，并且默认缩放比例为1.0。</p>
</blockquote>
</li>
<li><p><strong>媒体查询（Media Queries）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段CSS代码将在屏幕宽度小于或等于600px时，将<code>body</code>元素的字体大小设置为14px。</p>
</blockquote>
</li>
<li><p><strong>弹性布局（Flexbox）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子将一个容器内的子元素以垂直方向排列，适应不同尺寸的移动设备屏幕。</p>
</blockquote>
</li>
<li><p><strong>REM和EM单位：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>; <span class="comment">/* 假设根元素的基础字体大小为16px */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.2rem</span>; <span class="comment">/* 相对于根元素的字体大小，这里相当于19.2px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子中，使用REM单位相对于根元素的字体大小进行设置。</p>
</blockquote>
</li>
</ol>
<h4 id="PC端屏幕适配："><a href="#PC端屏幕适配：" class="headerlink" title="PC端屏幕适配："></a>PC端屏幕适配：</h4><ol>
<li><p><strong>媒体查询（Media Queries）：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">1024px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这段CSS代码在屏幕宽度大于等于1024px时，将容器的宽度设置为960px，并水平居中显示。</p>
</blockquote>
</li>
<li><p><strong>百分比布局：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* 相对于父元素宽度的50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子中，元素的宽度被设置为其父元素宽度的50%。</p>
</blockquote>
</li>
<li><p><strong>最大宽度设置：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">1200px</span>; <span class="comment">/* 最大宽度为1200px */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; <span class="comment">/* 如果屏幕宽度小于1200px，则宽度为100% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子中，元素的最大宽度被设置为1200px，但如果屏幕宽度小于这个值，则会自动调整为100%。</p>
</blockquote>
</li>
<li><p><strong>栅格系统：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 这个列会占据父容器的一半宽度，当屏幕宽度较小时，它会自动调整 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-md-6&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 另一个占据父容器的一半宽度的列 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是Bootstrap栅格系统的一个简单示例，它可以根据屏幕宽度自动调整列的大小。</p>
</blockquote>
</li>
</ol>
<p><strong>VH单位：(二者都适用)</strong></p>
<blockquote>
<p>VH单位表示视窗高度的百分比。使用vh单位可以确保元素相对于视窗高度进行适配，这在移动端和PC端都很有用。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50vh</span>; <span class="comment">/* 元素高度为视窗高度的50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个示例中，元素的高度设置为视窗高度的50%，这样无论是在移动设备还是PC上，该元素始终会占据屏幕高度的一半。</p>
</blockquote>
<p><strong>JavaScript适配：</strong></p>
<blockquote>
<p>JavaScript可以通过检测设备的屏幕宽度和高度，然后根据具体情况动态调整页面元素的大小、布局和样式。以下是一个简单的JavaScript示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取视口的宽度和高度</span></span><br><span class="line"><span class="keyword">var</span> viewportWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line"><span class="keyword">var</span> viewportHeight = <span class="variable language_">window</span>.<span class="property">innerHeight</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据视口宽度和高度进行动态调整</span></span><br><span class="line"><span class="keyword">if</span> (viewportWidth &lt; <span class="number">600</span>) &#123;</span><br><span class="line">    <span class="comment">// 移动端样式</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;14px&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (viewportWidth &gt;= <span class="number">600</span> &amp;&amp; viewportWidth &lt; <span class="number">1024</span>) &#123;</span><br><span class="line">    <span class="comment">// 平板样式</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;16px&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// PC端样式</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span>.<span class="property">fontSize</span> = <span class="string">&quot;18px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个示例根据视口的宽度动态设置了<code>body</code>元素的字体大小，以实现简单的移动端、平板和PC端的屏幕适配。JavaScript还可以用于更复杂的适配场景，例如根据设备类型加载不同的样式文件或动态调整元素的布局等。</p>
</blockquote>
<h3 id="77、路由懒加载和异步组件"><a href="#77、路由懒加载和异步组件" class="headerlink" title="77、路由懒加载和异步组件"></a>77、路由懒加载和异步组件</h3><h3 id="78、Promise详细讲解"><a href="#78、Promise详细讲解" class="headerlink" title="78、Promise详细讲解"></a>78、Promise详细讲解</h3><h4 id="1、Promise是什么"><a href="#1、Promise是什么" class="headerlink" title="1、Promise是什么"></a>1、Promise是什么</h4><ol>
<li>抽象表达<ul>
<li>Promise是一门新的技术（ES6规范）</li>
<li>Promise是JS中进行异步编程的新的解决方案（旧的解决方案是单纯的回调函数）</li>
</ul>
</li>
<li>具体表达：<ul>
<li>从语法上来说：Promise是一个构造函数</li>
<li>从功能上来说：promise对象用来封装一个异步操作并可以获取其成功&#x2F;失败的结果值</li>
</ul>
</li>
</ol>
<h4 id="2、为什么要用Promise"><a href="#2、为什么要用Promise" class="headerlink" title="2、为什么要用Promise"></a>2、为什么要用Promise</h4><ol>
<li><p>promise在指定回调函数的方式更加灵活</p>
<ul>
<li>旧的：必须在启动异步任务前指定</li>
<li>promise:启动异步任务 &#x3D;&gt; 返回promise对象 &#x3D;&gt; 给promise对象绑定回调函数（甚至可以在异步任务结束后指定一个&#x2F;多个）</li>
</ul>
</li>
<li><p>支持链式调用，可以解决回调地狱的问题</p>
<ul>
<li><p>回调地狱是指：回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调执行的条件</p>
<ul>
<li><pre><code class="js">asyncFunc1(opt, (...args1) =&gt; &#123;
    asyncFunc2(opt, (...args2) =&gt; &#123;
        asyncFunc3(opt, (...args3) =&gt; &#123;
            asyncFunc4(opt, (...args4) =&gt; &#123;
                ...
            &#125;)
        &#125;)
    &#125;)
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 回调地狱的缺点：不便于阅读和异步处理</span><br><span class="line"></span><br><span class="line">3. 解决方案</span><br><span class="line"></span><br><span class="line">   - promise链式调用</span><br><span class="line"></span><br><span class="line">4. promise的基本使用</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   //resolve 解决  函数类型的数据</span><br><span class="line">   //reject 拒绝  函数类型的数据</span><br><span class="line">   const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">       setTimeout(() =&gt; &#123;</span><br><span class="line">           if(成功) &#123;</span><br><span class="line">               resolve(value); //将 promise 对象的状态设置为 【成功】</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               reject(err); //将 promise 对象的状态设置为 【失败】</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, 1000)</span><br><span class="line">   &#125;)</span><br><span class="line">   //调用 then 方法</span><br><span class="line">   p.then((value) =&gt; &#123;</span><br><span class="line">       成功时的回调</span><br><span class="line">   &#125;, (reason) =&gt; &#123;</span><br><span class="line">       失败时的回调</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>util.promisify的使用</p>
<ul>
<li><p>它可以将以前的那种基于回调函数的异步函数转换为promise</p>
</li>
<li><pre><code class="js">//引入 util 模块
const util = require(&#39;util&#39;)
//引入 fs 模块
const fs = require(&#39;fs&#39;)
//返回一个新的函数
let myReadFile = util.promisify(fs.readFile)

myReadFile(&#39;./resource/content.txt&#39;).then(value=&gt; &#123;
    console.log(value.toString())
&#125;)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 封装一个AJAX请求</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   function sendAJAX(url) &#123;</span><br><span class="line">       return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">           const xhr = new XMLHttpRequest()</span><br><span class="line">           xhr.open(&quot;GET&quot;, url)</span><br><span class="line">           xhr.send()</span><br><span class="line">           //处理结果</span><br><span class="line">           xhr.onreadystatechange = function() &#123;</span><br><span class="line">               if(xhr.readyState === 4) &#123;</span><br><span class="line">                   //判断成功</span><br><span class="line">                   if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) &#123;</span><br><span class="line">                       //成功的结果</span><br><span class="line">                       resolve(xhr.response)</span><br><span class="line">                   &#125;else &#123;</span><br><span class="line">                       reject(xhr.status)</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   sendAJAX(url).then(value =&gt; &#123;&#125;,reason =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>promise的状态改变</p>
<ul>
<li>promise的状态其实就是实例对象中的一个属性 【PromiseState】</li>
<li>pending   未决定的</li>
<li>resolved &#x2F; fullfilled   成功</li>
<li>rejected   失败</li>
</ul>
</li>
<li><p>Promise对象的值</p>
<ul>
<li>实例对象中的另一个属性 【PromiseResult】保存着对象异步任务 【成功&#x2F;失败】的结果</li>
<li>可以通过resolve和reject函数去修改</li>
</ul>
</li>
<li><p>中断Promise链条</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="comment">//有且只有一个方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123;&#125;)<span class="comment">//返回一个pending状态的promise</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="79、Vue和jQuery的区别："><a href="#79、Vue和jQuery的区别：" class="headerlink" title="79、Vue和jQuery的区别："></a>79、Vue和jQuery的区别：</h3><blockquote>
<p>Vue和jQuery对比jQuery是使用选择器（）选取DOM对象，对其进行赋值、取值、事件绑定等操作，和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。</p>
<p>Vue则是通过Vue对象将数据和View完全分离开来了。对数据进行操作不再需要引用相应的DOM对象，他们通过Vue对象这个vm实现相互的绑定，这就是MVVM模型。</p>
</blockquote>
<h3 id="80、IntersectionObserver的使用"><a href="#80、IntersectionObserver的使用" class="headerlink" title="80、IntersectionObserver的使用"></a>80、IntersectionObserver的使用</h3><blockquote>
<p>供了一种异步观察目标元素与其祖先元素或顶级文档<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport">视口</a>（viewport）交叉状态的方法。其祖先元素或视口被称为根（root）。</p>
<p>当一个 <code>IntersectionObserver</code> 对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦 <code>IntersectionObserver</code> 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver">IntersectionObserver - Web API 接口参考 | MDN (mozilla.org)</a></p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903874302574599">超好用的API之IntersectionObserver - 掘金 (juejin.cn)</a></p>
</blockquote>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://zhangjunqigithub.github.io/blog">JQ Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://zhangjunqigithub.github.io/blog/2023/07/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/">https://zhangjunqigithub.github.io/blog/2023/07/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">前端常见理论知识</a></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.206fbddcfd785cb6351a60661235ee63?rik=PybKqjZUdBgvfw&amp;riu=http%3a%2f%2flogoju.cn%2fwp-content%2fuploads%2f2016%2f08%2flogoju.cn_2016-08-27_05-22-44.jpg&amp;ehk=DdmlhEY629M2WnHe69pOEVvxGFmMeRUaroJ6zsZ44JU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/10/01/TypeScript/" title="TypeScript基础"><img class="cover" src="https://tse1-mm.cn.bing.net/th/id/OIP-C.m4m_xmJrAndBw761wWzH1QHaE8?rs=1&amp;pid=ImgDetMain" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">TypeScript基础</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/07/01/%E5%90%8E%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="后端常见理论知识"><img class="cover" src="https://images.xiaozhuanlan.com/photo/2019/b06d03d15623548f487643fdbf1a4c9d.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next</div><div class="next_info">后端常见理论知识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/ZhangjunqiGithub/picture/master/blogAvator.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JQ Zhang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/blog/tags/"><div class="headline">Tags</div><div class="length-num">25</div></a><a href="/blog/categories/"><div class="headline">Categories</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZhangjunqiGithub/blog.git"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZhangjunqiGithub/blog.git" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%8E%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%88%B0%E6%90%9C%E7%B4%A2%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%8C%E8%BF%99%E4%B8%AD%E9%97%B4%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1、从在浏览器中输入URL到搜索到想要的网页的结果，这中间经历了哪些步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">2、进程与线程的联系和互相通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81https%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94http%E6%9B%B4%E5%AE%89%E5%85%A8"><span class="toc-number">3.</span> <span class="toc-text">3、https为什么比http更安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81html%E5%92%8Ccss%E7%9A%84%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F%EF%BC%8Ccss%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8D%E4%BC%9A%E9%98%BB%E5%A1%9Ehtml%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%8C%E4%BC%9A%E9%98%BB%E5%A1%9EHtml%E7%9A%84%E6%B8%B2%E6%9F%93%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.</span> <span class="toc-text">4、html和css的解析顺序，css的解析不会阻塞html的解析，会阻塞Html的渲染的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81DOMContentLoad%E5%92%8Cload%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.</span> <span class="toc-text">5、DOMContentLoad和load的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E5%85%B3%E4%BA%8E%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9requestAnimationFrame%E5%92%8CgetBoundingClientRect%E5%92%8CintersectionObserver"><span class="toc-number">6.</span> <span class="toc-text">6、重绘和回流是什么以及如何避免重绘和回流关于重绘和回流相关的方requestAnimationFrame和getBoundingClientRect和intersectionObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%BB%8E%E5%90%8E%E7%AB%AF%E8%AF%B7%E6%B1%82%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%90%8E%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%87%BA%E6%9D%A5%E6%80%A7%E8%83%BD%E4%BC%9A%E6%9B%B4%E5%A5%BD"><span class="toc-number">7.</span> <span class="toc-text">7、从后端请求到一个数组后如何渲染出来性能会更好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81DocumentFragment%E6%96%87%E6%A1%A3%E7%A2%8E%E7%89%87%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">8、DocumentFragment文档碎片列表优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81Mutationobserver%E7%94%A8%E4%BA%8E%E7%9B%91%E6%8E%A7DOM%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BE%8B%E5%A6%82%EF%BC%9A%E8%87%AA%E5%B7%B1%E5%9C%A8%E5%81%9A%E6%B0%B4%E5%8D%B0%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A6%81%E9%98%B2%E6%AD%A2%E5%88%AB%E4%BA%BA%E6%8A%8A%E6%B0%B4%E5%8D%B0%E7%BB%99%E5%88%A0%E6%8E%89%EF%BC%8C%E9%82%A3%E4%B9%88%E6%88%91%E4%BB%AC%E5%B0%B1%E9%9C%80%E8%A6%81%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E5%8E%BB%E7%9B%91%E6%8E%A7%E5%88%B0%E8%BF%99%E4%B8%AADOM%E8%A2%AB%E5%88%A0%E9%99%A4%E4%BA%86%EF%BC%8C%E6%AD%A4%E6%97%B6%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%86%8D%E5%8E%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%8B%E7%94%9F%E6%88%90%E6%B0%B4%E5%8D%B0%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AE%A1%E7%AE%97%E5%AE%88%E5%B1%8F%E6%97%B6%E9%97%B4"><span class="toc-number">9.</span> <span class="toc-text">9、Mutationobserver用于监控DOM的变化：使用场景例如：自己在做水印的时候，我们要防止别人把水印给删掉，那么我们就需要这个方法去监控到这个DOM被删除了，此时我们可以再去执行一下生成水印的方法。第二个就是这个方法还可以计算守屏时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81computed%E5%92%8Cwatch%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%EF%BC%9A%E5%A4%9A%E5%AF%B9%E4%B8%80%EF%BC%88%E7%BC%93%E5%AD%98%EF%BC%89%E7%9B%91%E5%90%AC%E5%B1%9E%E6%80%A7%EF%BC%9A%E4%B8%80%E5%AF%B9%E5%A4%9A%E3%80%82%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">10、computed和watch的使用场景和区别：计算属性：多对一（缓存）监听属性：一对多。响应式的原理(双向绑定的原理)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81dep%E5%92%8Cwatcher%E4%BA%92%E7%9B%B8%E6%94%B6%E9%9B%86"><span class="toc-number">11.</span> <span class="toc-text">11、dep和watcher互相收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81diff%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">12、diff算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81flex%E5%B8%83%E5%B1%80%EF%BC%88blog%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">13、flex布局（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81ES6%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">14.</span> <span class="toc-text">14、ES6：箭头函数为什么不能作为构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81promise%E7%9B%B8%E5%85%B3%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E9%97%AE%E9%A2%98"><span class="toc-number">15.</span> <span class="toc-text">15、promise相关的内容，解决回调地狱问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E9%9C%80%E6%B1%82%EF%BC%9A%E7%94%A8promise%E5%B0%81%E8%A3%85%E4%BA%86%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C5s%E5%90%8E%E8%BF%98%E6%B2%A1%E8%AF%B7%E6%B1%82%E5%88%B0%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B0%B1%E6%98%BE%E7%A4%BA%E8%AF%B7%E6%B1%82%E8%B6%85%E6%97%B6"><span class="toc-number">16.</span> <span class="toc-text">16、需求：用promise封装了一个请求数据的函数，如果5s后还没请求到数据，就显示请求超时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81promise%E7%9A%84all%E6%96%B9%E6%B3%95%EF%BC%9A%E8%AF%B7%E6%B1%82%E6%89%80%E6%9C%89%E9%83%BD%E6%88%90%E5%8A%9F%E6%89%8D%E4%BC%9A%E8%BF%94%E5%9B%9E%E6%88%90%E5%8A%9F%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%B1%E8%B4%A5%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%E9%82%A3%E4%B8%AA%E5%A4%B1%E8%B4%A5"><span class="toc-number">17.</span> <span class="toc-text">17、promise的all方法：请求所有都成功才会返回成功，如果有一个失败就会返回那个失败</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81promise%E7%9A%84allSettled%E6%96%B9%E6%B3%95"><span class="toc-number">18.</span> <span class="toc-text">18、promise的allSettled方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81async-await%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">19.</span> <span class="toc-text">19、async&#x2F;await解决了什么问题是如何解决的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E5%9B%BE%E7%89%87%E5%92%8C%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E3%80%81%E7%80%91%E5%B8%83%E6%B5%81%EF%BC%88blog%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">20、图片和路由懒加载、防抖、节流、瀑布流（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%93%8D%E5%BA%94%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%AF%B7%E6%B1%82%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">21、取消重复请求的问题，响应拦截器和请求拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81cookie%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">22、cookie和本地浏览器缓存有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81Vue3%E5%9C%A8Vue2%E4%B8%8A%E7%9A%84%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%9A%84-blog"><span class="toc-number">23.</span> <span class="toc-text">23、Vue3在Vue2上的优化，以及是如何优化的(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81JS%E9%97%AD%E5%8C%85%EF%BC%88blog%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">24、JS闭包（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-blog"><span class="toc-number">25.</span> <span class="toc-text">25、git的基本使用方法(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81JS%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E5%92%8Cvar%EF%BC%8Clet%EF%BC%8Cconst%E4%B8%89%E8%80%85%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%88blog%EF%BC%89"><span class="toc-number">26.</span> <span class="toc-text">26、JS全局作用域的特殊情况和var，let，const三者的特点和区别（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81JS%E9%A2%84%E8%A7%A3%E6%9E%90-blog"><span class="toc-number">27.</span> <span class="toc-text">27、JS预解析(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%EF%BC%88blog%EF%BC%89"><span class="toc-number">28.</span> <span class="toc-text">28、数组去重（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81JS%E7%9A%847%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">29.</span> <span class="toc-text">29、JS的7种基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81null%E5%92%8Cundefine%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">30.</span> <span class="toc-text">30、null和undefine的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E3%80%81ES6%E6%96%B0%E5%A2%9E%E4%BA%86%E9%82%A3%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%EF%BC%88blog%EF%BC%89"><span class="toc-number">31.</span> <span class="toc-text">31、ES6新增了那些数组方法（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E3%80%81JS%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88blog%EF%BC%89"><span class="toc-number">32.</span> <span class="toc-text">32、JS种常用容器的使用（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E3%80%81DOM%E4%BA%8B%E4%BB%B6%E6%B5%81%EF%BC%88blog%EF%BC%89"><span class="toc-number">33.</span> <span class="toc-text">33、DOM事件流（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E3%80%81e-target%E5%92%8Cthis%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88blog%EF%BC%89"><span class="toc-number">34.</span> <span class="toc-text">34、e.target和this的区别（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E3%80%81%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%EF%BC%88blog%EF%BC%89"><span class="toc-number">35.</span> <span class="toc-text">35、阻止事件冒泡和默认行为（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%88blog%EF%BC%89"><span class="toc-number">36.</span> <span class="toc-text">36、事件委托（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37%E3%80%81this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%EF%BC%88blog%EF%BC%89"><span class="toc-number">37.</span> <span class="toc-text">37、this的指向问题（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E3%80%81JS%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%EF%BC%88blog%EF%BC%89"><span class="toc-number">38.</span> <span class="toc-text">38、JS的执行机制（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E3%80%81JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-eventloop"><span class="toc-number">39.</span> <span class="toc-text">39、JS事件循环(eventloop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40%E3%80%81%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%88blog%EF%BC%89"><span class="toc-number">40.</span> <span class="toc-text">40、宏任务和微任务（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E3%80%81%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%88blog%EF%BC%89"><span class="toc-number">41.</span> <span class="toc-text">41、原型和原型链（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E3%80%81webSocket%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-blog"><span class="toc-number">42.</span> <span class="toc-text">42、webSocket的基本使用(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%AD%A5%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E4%BB%A5%E5%8F%8A%E4%BA%8C%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">43.</span> <span class="toc-text">43、什么是同步什么是异步以及二者的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44%E3%80%81%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">44.</span> <span class="toc-text">44、生成随机数的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45%E3%80%81TCP%E5%92%8CIP%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">45.</span> <span class="toc-text">45、TCP和IP、三次握手四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">46.</span> <span class="toc-text">46、浏览器的渲染原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVVM%E3%80%81MVC%E6%A8%A1%E5%9E%8B"><span class="toc-number">47.</span> <span class="toc-text">47、什么是MVVM、MVC模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E3%80%81Vue%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">48.</span> <span class="toc-text">48、Vue双向数据绑定的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E3%80%81Vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B-blog"><span class="toc-number">49.</span> <span class="toc-text">49、Vue的生命周期有哪些(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">50.</span> <span class="toc-text">50、常见的数组方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">51.</span> <span class="toc-text">51、什么是原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">52.</span> <span class="toc-text">52、常见的继承有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E3%80%81%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">53.</span> <span class="toc-text">53、后台管理系统中的权限管理是怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E3%80%81es6-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">54、es6 有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55%E3%80%81v-for-%E5%BE%AA%E7%8E%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%BB%91%E5%AE%9A-key"><span class="toc-number">55.</span> <span class="toc-text">55、v-for 循环为什么一定要绑定 key ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E3%80%81%E5%B9%B3%E6%97%B6%E9%83%BD%E6%98%AF%E7%94%A8%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">56.</span> <span class="toc-text">56、平时都是用什么实现跨域的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57%E3%80%81this-%E7%9A%84%E6%8C%87%E5%90%91%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">57、this 的指向有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%B9%B3%E6%97%B6%E9%83%BD%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">58.</span> <span class="toc-text">58、谈谈你平时都用了哪些方法进行性能优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E3%80%81vue-%E5%AE%9E%E4%BE%8B%E6%98%AF%E6%8C%82%E8%BD%BD%E5%88%B0%E9%82%A3%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B8%8A%E7%9A%84%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">59、vue 实例是挂载到那个标签上的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60%E3%80%81%E8%AF%B7%E5%86%99%E8%87%B3%E5%B0%91%E4%B8%89%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F%EF%BC%88%E5%8E%9F%E7%94%9F-js%EF%BC%89"><span class="toc-number">60.</span> <span class="toc-text">60、请写至少三种数组去重的方法？（原生 js）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E3%80%81%E8%AF%B7%E5%86%99%E5%87%BA%E8%87%B3%E5%B0%91%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%8E%9F%E7%94%9F-js%EF%BC%89"><span class="toc-number">61.</span> <span class="toc-text">61、请写出至少两种常见的数组排序的方法（原生 js）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">62.</span> <span class="toc-text">62、清除浮动的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E3%80%81ES6%E4%B8%AD%E7%9A%84class%E7%B1%BB"><span class="toc-number">63.</span> <span class="toc-text">63、ES6中的class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E3%80%81%E8%B0%88%E8%B0%88%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">64.</span> <span class="toc-text">64、谈谈盒子模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E5%BE%81%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%83%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">65、箭头函数有哪些特征，请简单描述一下它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84300ms%E5%BB%B6%E8%BF%9F%E7%9A%84%E9%97%AE%E9%A2%98-blog"><span class="toc-number">66.</span> <span class="toc-text">66、移动端点击事件的300ms延迟的问题(blog)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">67.</span> <span class="toc-text">67、什么是同源策略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68%E3%80%81http-%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">68、http 状态码分别代表什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E3%80%81%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98-%EF%BC%9ACSRF-%E5%92%8C-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">69、安全问题 ：CSRF 和 XSS 攻击？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E3%80%81CSRF-%E5%92%8C-XSS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">70.</span> <span class="toc-text">70、CSRF 和 XSS 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E3%80%81call-apply-bind-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">71.</span> <span class="toc-text">71、call  apply  bind 三者的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E3%80%81%E7%8A%B6%E6%80%81%E7%A0%81304"><span class="toc-number">72.</span> <span class="toc-text">72、状态码304</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E3%80%81exports-module-exports%E5%92%8CJS%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88blog%EF%BC%89"><span class="toc-number">73.</span> <span class="toc-text">73、exports  module.exports和JS模块加载机制（blog）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E3%80%81%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">74.</span> <span class="toc-text">74、运算规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88npm-install-hexo-markmap%EF%BC%89"><span class="toc-number">75.</span> <span class="toc-text">75、类型转换（npm install hexo-markmap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%92%8CPC%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D"><span class="toc-number">76.</span> <span class="toc-text">76、移动端和PC端如何实现屏幕适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%EF%BC%9A"><span class="toc-number">76.1.</span> <span class="toc-text">移动端屏幕适配：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PC%E7%AB%AF%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%EF%BC%9A"><span class="toc-number">76.2.</span> <span class="toc-text">PC端屏幕适配：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#77%E3%80%81%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">77.</span> <span class="toc-text">77、路由懒加载和异步组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E3%80%81Promise%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3"><span class="toc-number">78.</span> <span class="toc-text">78、Promise详细讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81Promise%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">78.1.</span> <span class="toc-text">1、Promise是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Promise"><span class="toc-number">78.2.</span> <span class="toc-text">2、为什么要用Promise</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E3%80%81Vue%E5%92%8CjQuery%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">79.</span> <span class="toc-text">79、Vue和jQuery的区别：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80%E3%80%81IntersectionObserver%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">80.</span> <span class="toc-text">80、IntersectionObserver的使用</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/08/01/react%E5%88%9D%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="react初学常见问题"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.SotMiIQcjpM3eBVDEkbS-wHaD8?w=337&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.3&amp;pid=1.7" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="react初学常见问题"/></a><div class="content"><a class="title" href="/blog/2024/08/01/react%E5%88%9D%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="react初学常见问题">react初学常见问题</a><time datetime="2024-07-31T16:00:00.000Z" title="Created 2024-08-01 00:00:00">2024-08-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/07/18/vpn/" title="vpn的基本使用"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.f0abe0bdd8b028b028157289a444bb79?rik=euz5UmzThXRJjg&amp;riu=http%3a%2f%2fupload.qianlong.com%2f2017%2f0126%2f1485416801114.png&amp;ehk=6%2bpn%2fM5gYUSpXsRpr%2b7J35AvCcZ47ghsGr5HELFU7Tc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="vpn的基本使用"/></a><div class="content"><a class="title" href="/blog/2024/07/18/vpn/" title="vpn的基本使用">vpn的基本使用</a><time datetime="2024-07-17T16:00:00.000Z" title="Created 2024-07-18 00:00:00">2024-07-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/04/25/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE/" title="文献查找"><img src="https://www.editage.cn/insights/sites/default/files/iStock_000002193842Medium_0_0.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="文献查找"/></a><div class="content"><a class="title" href="/blog/2024/04/25/%E6%96%87%E7%8C%AE%E6%9F%A5%E6%89%BE/" title="文献查找">文献查找</a><time datetime="2024-04-24T16:00:00.000Z" title="Created 2024-04-25 00:00:00">2024-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2024/04/01/flutter/" title="flutter"><img src="https://pic4.zhimg.com/v2-6ed60bca7d0b1bcd936533374f26aa9c_720w.jpg?source=172ae18b" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="flutter"/></a><div class="content"><a class="title" href="/blog/2024/04/01/flutter/" title="flutter">flutter</a><time datetime="2024-03-31T16:00:00.000Z" title="Created 2024-04-01 00:00:00">2024-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/11/14/Docker%E5%9F%BA%E7%A1%80/" title="Docker基础"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.ovKcH9h3yTrNnMSldGHdJgHaD4?rs=1&amp;pid=ImgDetMain" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Docker基础"/></a><div class="content"><a class="title" href="/blog/2023/11/14/Docker%E5%9F%BA%E7%A1%80/" title="Docker基础">Docker基础</a><time datetime="2023-11-13T16:00:00.000Z" title="Created 2023-11-14 00:00:00">2023-11-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By JQ Zhang</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js?v=4.13.0"></script><script src="/blog/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch@4.22.1/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.65.0/dist/instantsearch.production.min.js"></script><script src="/blog/js/search/algolia.js?v=4.13.0"></script></div></div><script src="/blog/js/markmap.js"></script></body></html>